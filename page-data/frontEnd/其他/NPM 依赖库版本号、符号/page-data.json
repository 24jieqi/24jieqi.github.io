{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontEnd/其他/NPM 依赖库版本号、符号/","result":{"data":{"site":{"siteMetadata":{"title":"HJGP技术知识库"}},"markdownRemark":{"id":"a8e1fed6-abc0-518e-838d-bbceb4c1c21b","excerpt":"X.Y.Z  语义化版本。 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API…","html":"<h2>X.Y.Z</h2>\n<p><code class=\"language-text\">semver</code> 语义化版本。</p>\n<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n<ol>\n<li>主版本号：当你做了不兼容的 API 修改，</li>\n<li>次版本号：当你做了向下兼容的功能性新增，</li>\n<li>修订号：当你做了向下兼容的问题修正。</li>\n</ol>\n<p>先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n<p><a href=\"https://semver.org/lang/zh-CN/\">深入了解</a></p>\n<h2>版本号前面符号的意义</h2>\n<p><code class=\"language-text\">npm</code> 5 版本以后对于依赖会采用扁平化管理，简单说会收集当前项目/库所有的依赖库，形成一个资源表，根据依赖规则下载依赖文件，放置 <code class=\"language-text\">node_modules</code> 文件夹下。如果对同一个依赖有不同版本的情况，根据规则选择合适的放置 <code class=\"language-text\">node_modules</code> 根目录，冲突版本放置库的 <code class=\"language-text\">node_modules</code> 文件夹内。</p>\n<p>大概的目录结构</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">|-- node_modules\n|--|-- base@1.1.1\n|--|-- lib1@1.1.0\n|--|-- lib2@1.0.1\n|--|--|-- node_modules\n|--|--|--|-- base@0.1.0\n|--|-- lib3@1.0.0\n|-- package.json</code></pre></div>\n<p>同样依赖 <code class=\"language-text\">base</code> 库，但是版本不一致。</p>\n<h3>没有任何符号</h3>\n<blockquote>\n<p>1.0.0</p>\n</blockquote>\n<p>完全百分百匹配，当前库/项目必须使用当前版本号，如果和其他依赖使用了相同库不同版本，会在库的文件夹下建立一个 <code class=\"language-text\">node_modules</code> 文件夹存放它需要依赖的版本文件。</p>\n<h3>>、>=、&#x3C;、&#x3C;=</h3>\n<blockquote>\n<p>>1.0.0</p>\n</blockquote>\n<p>必须大于某个版本，例如，可以使用 1.0.1、1.1.1 、2.0.0 的版本。</p>\n<blockquote>\n<p>>=1.0.0</p>\n</blockquote>\n<p>必须大于或等于某个版本，例如，可以使用 1.0.0、1.0.1、1.1.1 、2.0.0 的版本。</p>\n<blockquote>\n<p>&#x3C; 1.0.0</p>\n<p>&#x3C;=1.0.0</p>\n</blockquote>\n<p>小于、小于等于参考大于、大于等于。</p>\n<h3>~</h3>\n<blockquote>\n<p>~1.0.0</p>\n</blockquote>\n<p>不改变大版本号和次要版本号，小版本号随意，例如，可以使用 1.0.1、1.0.3 的版本，版本号保持 1.0.x 格式就可以通用。</p>\n<h3>^</h3>\n<blockquote>\n<p>^1.0.0</p>\n</blockquote>\n<p>版本号最左边非 0 数字的右侧可以任意，例如，可以使用 1.0.1、1.2.0 的版本，版本号保持 1.x.x 格式就可以通用。</p>\n<h3>x</h3>\n<blockquote>\n<p>1.0.x 或 1.x</p>\n</blockquote>\n<p>x 的位置即后面表示任意版本，例如，可以使用 1.0.2/1.11.1 的版本。</p>\n<h3>*</h3>\n<blockquote>\n<p>“base”: ”*”</p>\n</blockquote>\n<p>任意版本。</p>\n<h3>-</h3>\n<blockquote>\n<p>“base”: “1.0.1-1.5.9”</p>\n</blockquote>\n<p>在这两个版本号之间的版本可以通用。</p>\n<h3>||</h3>\n<blockquote>\n<p>“base”: “1.1.1||^2.1.1”</p>\n</blockquote>\n<p>多个版本规则都适用。</p>\n<h2>注意点</h2>\n<p>在初次安装依赖的时候，npm 会生成一个 <code class=\"language-text\">package-lock.json</code> 文件，yarn 生成一个 <code class=\"language-text\">yarn.lock</code> 文件，把当前时间点的依赖关系固定，就算删除 <code class=\"language-text\">node_modules</code> 也不会改变。</p>\n<p>如果项目/库更改了依赖的版本，最好删除两个锁定文件重新安装，如果不，会出现依赖关系错乱，在原依赖内生成不必要的文件。</p>\n<p>例如 lib1 依赖 <code class=\"language-text\">'base':'^1.1.0' </code>，项目依赖 <code class=\"language-text\">'base':'1.2.0'</code>，初次安装会在 <code class=\"language-text\">node_modules</code> 根目录放置 base 库。</p>\n<p>手动改变项目依赖 <code class=\"language-text\">'base':'1.7.0'</code>，直接安装依赖，这时候 lib1 文件夹内会有一个独立的 <a href=\"mailto:base@1.2.0\">base@1.2.0</a> 的版本。这是因为锁版本文件以及预置了 lib1 当前依赖关系，并不是每次都会动态变更。</p>\n<p>如果使用非固定模式，如果远程仓库更新/高版本，会默认采用能匹配到的最新版本号。<strong>非固定和固定模式搭配容易出现依赖中带有私有版本的文件。</strong></p>","frontmatter":{"title":"NPM 依赖库版本号、符号","date":"2021-11-03","description":null,"author":"onlyling"}},"previous":{"fields":{"slug":"/frontEnd/其他/JavaScript实现一个LazyMan/"},"frontmatter":{"title":"JavaScript实现一个LazyMan"}},"next":{"fields":{"slug":"/frontEnd/其他/PDF 单位尺寸与像素转换/"},"frontmatter":{"title":"PDF 单位尺寸与像素转换"}}},"pageContext":{"id":"a8e1fed6-abc0-518e-838d-bbceb4c1c21b","previousPostId":"b96320b1-9176-5847-b680-aa4111de8343","nextPostId":"bf58eca1-68a6-5491-8523-a52f4a88402b"}},"staticQueryHashes":["2841359383","3257411868"]}