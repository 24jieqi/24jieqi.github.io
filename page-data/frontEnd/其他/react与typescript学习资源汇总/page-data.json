{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontEnd/其他/react与typescript学习资源汇总/","result":{"data":{"site":{"siteMetadata":{"title":"HJGP技术知识库"}},"markdownRemark":{"id":"55ada83f-1871-5ed9-8c4a-140841254585","excerpt":"1.React 1.Refs & DOM ref 的值根据节点的类型而有所不同：\n当 ref 属性用于 HTML 元素时，构造函数中使用  React.createRef()创建的 ref 接收底层 DOM 元素作为其 current 属性。\n当 ref 属性用于自定义 class 组件时，ref…","html":"<h2>1.React</h2>\n<h3>1.Refs &#x26; DOM</h3>\n<p>ref 的值根据节点的类型而有所不同：\n当 ref 属性用于 HTML 元素时，构造函数中使用  React.createRef()创建的 ref 接收底层 DOM 元素作为其 current 属性。\n当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。\n你不能在函数组件上使用  ref  属性因为他们没有实例;但是可以在函数组件内部使用  ref  属性，只要它指向一个 DOM 元素或 class 组件：</p>\n<h3>2.state 和 props</h3>\n<p>state：用于组件内部传递数据，它是私有属性，不能够直接修改，因为直接修改后页面也不会重新渲染，数据没有得到更新，要修改的话要在 this.setState 内部。state 的初始化只能在构造函数中。state 不能依赖当前的 state 计算下一个 state,可以使用函数传参。\nprops:用于组件之间传递数据，父组件向子组件传值，是只读的，不能修改的。\nsetState 是异步更新，同步执行，它提供两个参数，第一个接收一个对象类型，使用对象来更新 state，第一个参数也可以传入一个函数，这样可以轻易地拿到上一个状态的信息。,第二个参数是组件 state 的异步操作处理，传入一个函数，这样可以轻易拿到上一个状态的信息。</p>\n<h3>3.高阶组件</h3>\n<p>实现状态逻辑的复用，高阶组件是一个函数，接收要包装的组件，返回一个增强的组件\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n实现步骤：</p>\n<ul>\n<li>创建一个函数</li>\n<li>传递一个参数，以大写字母开头</li>\n<li>在函数内部创建一个类组件，里面写状态复用的逻辑代码并返回</li>\n<li>在该组件中渲染参数组件，同时将状态通过 props 传递给参数组件</li>\n<li>调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染在页面上</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function logProps(WrappedComponent) {\nreturn class extends React.Component {\ncomponentDidUpdate(prevProps) {\nconsole.log('Current props: ', this.props);\nconsole.log('Previous props: ', prevProps);\n}\nrender() {\nreturn &lt;WrappedComponent {...this.props} />;\n}\n}\n}\n//创建组件\nconst logPropsHoc = logProps(otherComponent)\n//渲染\n&lt;logPropsHoc /></code></pre></div>\n<h3>4.深入 JSX</h3>\n<p><strong>(1)指定 React 元素类型</strong>\nReact 必须在作用域内\n在 JSX 中使用点语法\n定义的组件必须以大写字母开头\n在运行时选择类型\n<strong>(2)JSX 中的 props</strong>\njs 表达式作为 props:if 语句以及 for  循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。\n可以将字符串字面量赋值给 prop\nprops 默认为 true\n属性展开：如果你已经有了一个 props 对象，你可以使用展开运算符   在 JSX 中传递整个 props 对象。\n<strong>(3)JSX 中的子元素</strong>\n字符串字面量：可以将字符串放在开始和结束标签之间，此时  props.children  就只是该字符串。\nJSX 子元素：子元素允许由多个 JSX 元素组成\njs 表达式作为子元素\n函数作为子元素\n布尔类型、Null 以及 Undefined 将会忽略：false, null, undefined, and true  是合法的子元素。但它们并不会被渲染</p>\n<h3>5.受控组件和非受控组件</h3>\n<p>非受控组件：使用非受控组件，表单数据将有 DOM 节点来处理，一般没有 value，我们就可以认为这个组件是非受控组件，但是我们可以通过 defaultValue 来给\n初始值。\n受控组件：</p>\n<ul>\n<li>通过在初始 state 中设置表单的默认值</li>\n<li>每当表单的值发生变化时，调用 onChange 事件处理器</li>\n<li>事件处理器通过合成对象 e 拿到改变后的状态，并更新应用的 state</li>\n<li>SetState 触发视图的重新渲染，完成表单组件值的更新</li>\n</ul>\n<h3>6.React 组件的生命周期</h3>\n<p>（1）生命周期的初始化阶段：\n构造函数阶段和：初始化组件 state\ncomponentDidMount:组件创建好 DOM 元素之后被调用一次\n（2）生命周期的更新阶段：</p>\n<ul>\n<li>state getDerivedStateFromProps(nextProps, prevState){}在组件初始化和更新都会被调用，用来对比当前的 props 和之前的 state 变化</li>\n<li>shouldComponentUpate(nextProps, nextState)，通过判断 props 和 state 的变化控制组件是否需要被更新，当我们不使用这个函数的时候，state 和 props 有任何变化，组件就会被马上更新，UI 也会被重新渲染，但是每次渲染 UI 都会带来很大的资源开销，所以我们需要通过这个函数来判断什么时候需要实现组件的更新。\n例子：shouldComponentUpate(nextProps, nextState){\nreturn nextState.some !== this.state.some}//返回的是一个布尔值，ture 的时候就更新，false 的时候就不更新</li>\n<li>componentDidUpdate(){}//组件更新后被调用</li>\n</ul>\n<p>（3）生命周期的销毁阶段：\ncomponentWillUnmount(){}组件销毁后调用，可以回收各种监听以及事件，用来避免组件销毁时可能存在的内存泄漏</p>\n<!-- ![1](https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE10630691ceec1e0f4ec7c75dd913143e/934) -->\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE10630691ceec1e0f4ec7c75dd913143e/934\" width=\"630\" height=\"400\">\n<h2>2.React Hooks</h2>\n<p>hooks:消息处理的一种方法，用来监视指定程序，当函数式组件例如需要实现 API 数据访问或者异步修改组件状态的时候。函数组件中组要处理副作用，可以用钩子函数把外部代码”钩进来“\nhooks 本质：一类特殊的函数，为你的函数式组件注入特殊的功能\n注意：\n只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。\n只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用</p>\n<h3>1.useState（）</h3>\n<p>const [count, setCount] = useState(0)//这个 useState 函数里面的值是 count 的状态初始化值\nReact 自带的 hook 函数，声明组件状态\n参数可以设置 state 的初始值\n返回值是一个只有两个元素的数组:[状态，状态更新]\n里面的 setCount 方法是异步的，没有重载，所以不能提供异步处理的回调接口，所以当我们连续写多个 setCount 的时候，count 还是只会加 1 次</p>\n<h3>2.Effect Hook</h3>\n<p>useEffect 执行副作用操作（获取数据、设置/清除定时器以及手动修改 DOM\n格式：useEffect(callback, deps),callback 回调，deps 依赖数组\n回调执行：DOM 渲染的时候，执行一次 callback，组件更新的时候也会执行一次 callback，React 每次渲染都会执行 callback.\ndeps:依赖数组，通过依赖数组里面的依赖项控制回调执行的次数\n(1)无需清除的 Effect\n想在 React 更新 DOM 之后运行一些额外的代码。比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。\n(2)需要清除的 Effect\n一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！比如：定时器/延时器\n副作用中回调函数返回一个函数（销毁函数），作为副作用的清除</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Child = () =>{\n    useEffect(() => {\n        const timer = setInterval(() => {\n            console.log('定时器')\n        },1000)\n        //返回的函数就是将要卸载的函数\n        return () => {\n            clearInterval(timer)\n        }\n    },[])\n    return(\n        &lt;div>\n            &lt;h1>子组件&lt;/h1>\n        &lt;/div>\n    )\n}</code></pre></div>\n<p>useEffect 的第二个参数，useEffect 的第二个参数，有三种情况\n什么都不传，组件每次 render 之后 useEffect 都会调用，相当于 componentDidMount 和 componentDidUpdate\n传入一个空数组 [], 只会调用一次，相当于 componentDidMount 和 componentWillUnmount\n传入一个数组，其中包括变量，只有这些变量变动时，useEffect 才会执行</p>\n<h3>3.useRef</h3>\n<p>useRef  返回一个可变的 ref 对象，其  .current  属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。\n（1）绑定 DOM 节点，或者 React 元素\n（2）保持可变变量</p>\n<h3>4.useReduce</h3>\n<p>useState 的替代方案\n使用场景：例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state.</p>\n<h3>5.useContext</h3>\n<p>context 在 React 中，解决一个跨多层组件传递的数据问题，useContext 能够在函数组件中使用 context,替换之前的 context.Consumer\n（1）实现从上到下跨多层组件传递数据\n（2）兄弟组件交互数据（共享数据）\n（3）配合 useReducer 组合 redux</p>\n<h3>6.useCallback</h3>\n<p>使用场景：\n(1)父组件状态如果发生变化，即使子组件不需要更新，子组件也会因为父组件重新渲染而跟着重新渲染，这时可以使用 React.memo 来阻止子组件进行不必要的更新。如果父组件通过 props 传递给子组件一个函数，即使用了 React.memo，子组件也会因为父组件传递过来的 props 发生变化而重新渲染，这时就需要使用 useCallback 缓存一下这个函数,在传递给子组件。\n(2)防抖函数、节流函数</p>\n<h3>7.useMemo</h3>\n<p>useMemo 功能是判断组件中的函数逻辑是否重新执行，用来优化性能。\n使用场景：\n(1)一个值需要大量计算，可以使用 useMemo 做一个缓存，只有在依赖项更新时才会重新计算\n(2)一个组件只有在依赖项更新时才重新渲染，也可以使用 useMemo\nuseCallback 和 useMemo 的区别：useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p>\n<h2>3.React Hooks 练习</h2>\n<h3>1.自定义 hook,实现点击切换状态</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function SomeComponent() {\n  const [state, toggleState] = useToggle(false);\n  return &lt;div>\n    {state ? 'true' : 'false'}\n    &lt;button onClick={toggleState}>&lt;/button>\n  &lt;/div>\n}\n\n// 请实现 useToggle\nfunction useToggle(initialValue) {\n    const [value, setValue] = useState(initialValue);\n    const toggle = () => {setValue(!value)};\n    return [value, toggle];\n}</code></pre></div>\n<h3>2.useEffect</h3>\n<p>useEffect\n(1)依赖数组依赖的值最好不要超过 3 个，否则会导致代码会难以维护\n(2)依赖项过多问题 a. 去掉不必要的依赖 b. 将 Hook 拆分为更小的单元，每个 Hook 依赖于各自的依赖数组 c. 合并相关的 state，将多个依赖值聚合为一个 d. 通过 setState 回调函数获取最新的 state，以减少外部依赖 e. 通过 ref 来读取可变变量的值，不过需要注意控制修改它的途径\n(3)useEffect 和生命周期函数不做类比，useEffect 单纯用作处理副作用\n受控组件：利用 props，去修改内部的 state</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React, { useState, useEffect } from 'react';\n\ninterface Props {\n  value: number,\n  onChange: (num: number) => any\n}\n\nexport default function Counter({ value, onChange }: Props) {\n  const [count, setCount] = useState&lt;number>(0);\n\n  useEffect(() => {\n    value &amp;&amp; setCount(value);\n  }, [value]);\n\n  return [\n    &lt;div key=\"a\">{count}&lt;/div>,\n    &lt;button key=\"b\" onClick={() => onChange(count + 1)}>\n      点击+1\n    &lt;/button>\n  ]\n}</code></pre></div>\n<p>清除副作用:\na. 每次副作用执行，都会返回一个新的 clear 函数\nb. clear 函数会在下一次副作用逻辑之前执行（DOM 渲染完成之后）\nc. 组件销毁也会执行一次</p>\n<h2>4.TS</h2>\n<h3>1.TS 接口</h3>\n<p>接口是对 JavaScript 本身的随意性进行约束，通过定义一个接口，约定了变量、类、函数等应该按照什么样的格式进行声明，实现多人合作的一致性\n应用场景：在声明一个对象、函数、或者类时先定义接口，确保其数据结构的一致性</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Clothes {\n    color: string;\n    size: string;\n    readonly price: number;//只读属性，不能修改\n    buyname?: string;//可选属性\n}\nfunction getClothesInfo(clothes: Clothes) {\n    console.log(clothes.price)\n}\nlet myClothes: Clothes = {\n    color: 'black',\n    size: 'XL',\n    price: 98\n}\ngetClothesInfo(myClothes)\nmyClothes.price = 100 //报错</code></pre></div>\n<p>接口类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//函数类型\ninterface SearchFunc {\n    (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string): boolean {\n    return source.search(subString) > -1\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//可索引类型\ninterface ScenicInterface {\n    [index: number] :string\n}\nlet arr: ScenicInterface = ['西湖', '华山', '故宫']\nlet favorite: string = arr[0]//索引签名是 number类型，返回值是字符串类型</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//类类型\ninterface AnimalInterface {\n    name: string;\n}\nclass Dog implements AnimalInterface {\n    name: string;\n    constructor(name: string) {\n        this.name = name\n    }//接口只能含有抽象方法和成员属性，实现类中必须实现接口中所有的抽象方法和成员属性。\n}\ninterface AnimalInterface {\n    name: string;\n     eat(m: number): string\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//在接口中描述一个方法，在类里实现它\nclass Dog implements AnimalInterface {\n    name: string;\n    constructor(name: string) {\n        this.name = name\n    }\n    eat(m: number) {\n        return `${this.name}吃肉${m}分钟`\n    }\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//继承接口：接口也可以通过extends相互继承，使得可以从一个接口里复制成员到另一个接口\ninterface Shape {\n    color: string;\n}\ninterface Square extends Shape {\n    sideLength: number;\n}\nlet square = {} as Square\nsquare.color = \"blue\";\nsquare.sideLength = 10;</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//一个接口可以继承多个接口，创建出多个接口的合成接口\ninterface Shape {\n    color: string;\n}\ninterface PenStroke {\n    penWidth: number;\n}\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\nlet square = {} as Square;\nsquare.color = \"blue\";\nsquare.penWidth = 5.0\nsquare.sideLength = 10</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//混合接口:一个对象同时具有上面提到多种类型\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\nfunction  getCounter(): Counter {\n    let counter = function (start: number) { } as Counter;\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0</code></pre></div>\n<h3>2.TS 函数</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//函数类型\nconst add = function (x: number, y: number): string {\n    return ( x + y).toString()\n}</code></pre></div>\n<p>函数参数</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//1.参数个数保持一致\nconst fullName = (firstName: string, lastName: string): string => `${firstName}${lastName}`\nlet result = fullName('name1', 'name2')\n//2.可选参数\nconst fullName = (firstName: string, lastName ?: string): string => `${firstName}${lastName}`\nlet reslut1 = fullName('he')\n//3.默认参数\nconst token = (expired = 60 * 60, secret: string): void => { }\n//4.剩余参数：函数参数不确定，可能传入未知参数\nfunction assert(ok: boolean, ...args: string[]): void {\n    if (!ok) {\n        throw new Error(args.join(' '));\n    }\n\n}\nassert(false, '上传文件过大', '只能上传jpg格式')</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// this参数\nlet triangle = {\n    a: 10,\n    b: 15,\n    c: 20,\n    area: function () {\n        return () => {\n            //this为any类型,很危险，可以在 tsconfig.json 中，将编译选项 compilerOptions 的属性 noImplicitThis 设置为 true\n            const p = (this.a + this.b + this.c) / 2\n            return Math.sqrt(p * (p -this.a) * (p - this.b) * (p-this.c))\n        }\n     \n    }\n}\nconst myArea = triangle.area()\nconsole.log(myArea())\n//我们声明了一个接口 Triangle，其中的函数类型显式的传入了 this 参数，这个参数的类型为 Triangle 类型（第 5 行）：this 指向 Triangle，就可以进行正确的类型判断，如果取未定义参数，编译器将直接报错。\ninterface Triangle {\n    a: number;\n    b: number;\n    c: number;\n    area(this: Triangle): () => number;\n}\nlet triangle: Triangle = {\n    a: 10,\n    b: 15,\n    c: 20,\n    area: function (this: Triangle) {\n        return () => {\n            const p = (this.a + this.b + this.c) / 2\n            return Math.sqrt(p * (p -this.a) * (p - this.b) * (p-this.c))\n        }\n    }\n}\nconst myArea = triangle.area()\nconsole.log(myArea())</code></pre></div>\n<p>函数重载：函数根据传入不同的参数，返回不同类型的数据</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function reverse(x: string): string\nfunction reverse(y: number): number\nfunction reverse(target: string | number) {\n    if (typeof target === 'string') {\n        return target.split('').reverse().join('')\n    }\n    if (typeof target === 'number') {\n        return +[...target.toString()].reverse().join('')\n    }\n}\nconsole.log(reverse('imooc')) //coomi\nconsole.log(reverse(23874800)) //847832</code></pre></div>\n<h3>3.TS 类型断言</h3>\n<p>类型断言：当 TS 推断出来的类型并不满足你的需求的时候，你需要手动指定一个类型\n关键字 as</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//const user: {}这是一个没有属性的对象，所以你不能对其添加属性，此时可以使用类型断言（as关键字）覆盖其类型判断\ninterface User {\n    nickname: string,\n    admin: boolean,\n    groups: number[]\n}\nconst user = {} as User\nuser.nickname = 'Evan'\nuser.admin = true\nuser.groups = [2, 6]</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//首尾标签：类型断言还可以通过&lt;>来实现\ninterface User {\n    nickname: string,\n    admin: boolean,\n    groups: number[]\n}\nconst user = &lt;User>{}//User类型\nuser.nickname = 'Evan'\nuser.admin = true\nuser.groups = [2, 3]</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//非空断言！：如果编译器不能够去除null或undefined, 可以使用非空断言！手动去除\nfunction fixed(name: string | null): string {\n    function postfix(epithet: string) {\n        return name!.charAt(0) + '. the' + epithet; //name被断言为非空\n    }\n    name = name || \"Bob\"\n    return postfix(\"great\")\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//双重断言\ninterface User {\n    nickname: string,\n    admin: boolean,\n    group: number[]\n}\nconst user = 'Evan' as any as User</code></pre></div>\n<h3>4.TS 类型保护</h3>\n<p>类型保护：缩小类型的范围，在一块级作用域内由编译器推导其类型，提示并规避不合法的操作</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//typeof：判断基本类型\nfunction reverse(target: string | number) {\n    if (typeof target === 'string') {\n        target.toFixed(2) //Error,target是string类型，没有toFixed方法\n        return target.split('').reverse().join('')\n    }\n    if (typeof target === 'number') {\n        target.toFixed(2) //ok\n        return +[...target.toString()].reverse().join('')\n    }\n    target.forEach(Element => {})//Error,target 是 string 或 number 类型，没有 forEach 方法\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//instanceof:判断是否为某个对象的实例\nclass User {\n    public nickname: string | undefined\n    public group: number | undefined\n}\nclass Log {\n    public count: number = 10\n    public keyword: string | undefined\n}\nfunction typeGuard(arg: User | Log) {\n    if (arg instanceof User) {\n        arg.count = 15 //Error,User类型无此属性\n    }\n    if (arg instanceof Log) {\n        arg.count = 15 //ok\n    }\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//in:用于确定属性是否存在于某个对象上\nclass User {\n    public nickname: string | undefined\n    public groups!: number[]\n}\nclass Log {\n    public count: number = 10\n    public keyword: string | undefined\n}\nfunction typeGuard(arg: User | Log) {\n    if ('nickname' in arg) {\n        arg.nickname = 'imooc'//(parameter) arg: User，编辑器将推断在当前块作用域 arg 为 User 类型\n    }\n    if ('count' in arg) {\n        arg.count = 15//// (parameter) arg: Log，编辑器将推断在当前块作用域 arg 为 Log 类型\n    }\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//字面量类型保护\ntype Success = {\n    success: true,\n    code: number,\n    object: object\n}\ntype Fail = {\n    success: false,\n    code: number,\n    errMsg: string,\n    request: string\n}\nfunction test(srg: Success | Fail) {\n    if (arg.success === true) {\n        console.log(arg.obejct) //ok\n        console.log(arg.errMsg)// Error,通过布尔字面量，将arg类型限定为Success类型\n    } else {\n        console.log(arg.errMsg) //ok\n        console.log(arg.object) //error\n    }\n}</code></pre></div>\n<h3>5.TS 泛型</h3>\n<p>泛型：在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定\n语法：在函数名、接口名或者类名添加后缀<T></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function generic&lt;T>() { }\ninterface Generic&lt;T> { }\nclass Generic&lt;T> { }</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//初识泛型：它帮助我们为不同类型的输入，复用相同的代码\n//多个类型参数\nfunction extend&lt;T, U>(first: T, second: U): T &amp; U {\n    for (const key in second) {\n        (first as T &amp; U)[key] = second[key] as any\n    }\n    return first as T &amp; U\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//泛型参数默认类型\nfunction min&lt;T = number>(arr: T[]): T {\n    let min = arr[0]\n    arr.forEach((value) => {\n        if (value &lt; min) {\n            min = value\n        }\n    })\n    return min\n}\nconsole.log(min([20, 6, 8n]))//6</code></pre></div>\n<p>泛型类型与泛型接口</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//泛型类型\nfunction identity&lt;T>(arg: T): T {\n    return arg\n}\nlet myIdentity: &lt;T>(arg: T) => T = identity//另一种写法：let myIdentity { &lt;T>(arg: T): T} = identity</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//泛型接口\ninterface GenericIdentityFn {\n    &lt;T>(arg: T):T\n}\nfunction identity&lt;T>(arg: T): T {\n    return arg\n}\nlet myIdentity: GenericIdentityFn = identity</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> //泛型接口将泛型参数提前到接口名上\ninterface GenericIdentityFn&lt;T> {\n     (arg: T): T\n}\nfunction identity&lt;T>(arg: T): T{\n     return arg\n}\nlet myIdentity: GenericIdentityFn&lt;number> = identity</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//泛型类\nclass Minclass {\n    public list: number[] = []\n    add(num: number) {\n        this.list.push(num)\n    }\n    min(): number {\n        let minNum = this.list[0]\n        for (let i = 0; i &lt; this.list.length; i++){\n            if (minNum > this.list[i]) {\n                minNum = this.list[i]\n            }\n        }\n        return minNum\n    }\n}//还需要字符串类型，此时使用泛型\nclass Minclass&lt;T> {\n    public list: T[] = []\n    add(num: T) {\n        this.list.push(num)\n    }\n    min(): T {\n        let minNum = this.list[0]\n        for (let i = 0; i &lt; this.list.length; i++){\n            if (minNum > this.list[i]) {\n                minNum = this.list.[i]\n            }\n        }\n        return minNum\n    }\n}\nlet m = new Minclass&lt;string>()\nm.add('hello')\nm.add('nihao')\nconsole.log(m.min())</code></pre></div>\n<p>泛型约束：通过 extends 关键字来约束</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//例1：我们约束了入参 user 必须包含 username 属性，否则在编译阶段就会报错。\ninterface User {\n    username: string\n}\nfunction info&lt;T extends User>(user: T): string {\n    return 'imooc' + user.username\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//例2：\ntype Args = number | string\nclass MinClass&lt;T extends Args> { }\nconst m = new MinClass&lt;boolean>()//Error,必须是number | string类型\n//多重类型泛型约束：通过&lt;T extends Interface1 &amp; Interface2>这种语法来实现\ninterface Sentence {\n    title: string,\n    content: string\n}\ninterface Music {\n    url: string\n}\nclass Classic&lt;T extends Sentence &amp; Music>{\n    private prop: T\n    constructor(arg: T) {\n        this.prop = arg\n    }\n    info() {\n        return {\n            url: this.prop.url,\n            title: this.prop.title,\n            content:this.prop.content\n        }\n    }\n}</code></pre></div>\n<h3>6.TS 模块</h3>\n<p>（1）全局模块：在两个文件下都声明一个 a 常量，一个为 1，一个为 2，会报错，虽然在不同文件下，但处于同一全局空间，加上 export const a = 1 不会报错，这时两个 a 处于不同的命名空间\n（2）导出语法\n使用 export 导出声明，任何声明(变量、函数、类、类型别名、接口)都可以通过 export 关键字导出\n先声明，后导出，先进行声明操作，最终统一使用 export 关键字导出\n导出时，可以使用 as 进行重命名，比如：export {a as level, used as users}\n重新导出，通过 export * from ‘module\n默认导出，每个模块都有一个 default 导出，并且一个模块只能够有一个 default 导出\n（3）导入语法\n使用 import 导入\n导入时使用 as 重命名\n（4）export = 只能导出对象，它导出的模块只能使用 import = require()形式导入</p>\n<h3>7.TS 命名空间</h3>\n<p>命名空间：它的本质就是一个对象，将其内部的变量组织到这个对象的属性上，使用  namespace  关键字来声明命名空间。TypeScript 的命名空间可以将代码包裹起来，只对外暴露这个命名空间对象，通过  export  关键字将命名空间内的变量挂载到命名空间对象上。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">namespace Calculate {\n    const fn = (x: number, y: number) => x \\* y\n    export const add = (x: number, y: number) => x + y\n}\n//访问\nCalculate.add(2, 3)</code></pre></div>\n<h2>5.GraphQL 的生成过程</h2>\n<p>(1）首先在 playground 中输入自己想要的数据的对应接口，可以查看相应字段。例如：getPermission</p>\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCEc0607c79878e9d910a86e84110e7a127/907\" width=\"630\" height=\"400\">\n<p>(2）点击 SCHEMA 下载对应的 gql 文件</p>\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE43f4011e781e13c338805384b67fd663/910\" width=\"630\" height=\"400\">\n<p>(3）在 postman 中导入下载好的 gql 文件,选择了文件后直接点击 import</p>\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCEf0763a3d038d491ca337c24e277225d8/911\" width=\"630\" height=\"400\">\n<p>(4）在 postman 搜索框中输入对应接口字段，会自动生成 gql</p>\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE5919a5e48c0428325d89af3302296370/909\" width=\"630\" height=\"400\">\n<p>(5）将左边的 QUERY 数据直接复制到自己创建的以.gql 为后缀的文件，在命令行窗口输入对应命令（命令在配置文件中查看 pakage.json）会自动生成一个文件名.generated.ts 文件</p>\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE784fb020c3cbeda2d5f174f6cfe01411/908\" width=\"630\" height=\"400\">\n<img src=\"https://note.youdao.com/yws/public/resource/58a426efe470f8f88d98fa73bfd66f7a/xmlnote/WEBRESOURCE6c8b2a7cb0985c98a25fac5194e34059/906\" width=\"630\" height=\"400\">\n<h2>6.GraphQL 一些知识点</h2>\n<p>GraphQl：是用于 API 的查询语言，可以没有任何冗余的获取到自己需要的数据</p>\n<h3>1.GraphQL 的操作类型</h3>\n<p>Query、Mutation、substription\n（1）Query 查询：获取数据，相当于 get\n（2）Mutation 变更：对数据进行变更，像增删改\n（3）substription 订阅:当数据发生更改，</p>\n<h3>2.对象类型和标量类型</h3>\n<p>（1）对象类型为 schema 中定义的 type\n（2）标量类型：GraphQL 中内置有一些标量类型  String、Int、Float、Boolean、ID，用户也可以定义自己的标量类型</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type user {\n    name: string,\n    id: int!\n}</code></pre></div>\n<h3>3.模式 schema</h3>\n<p>它定义了字段的类型、数据的结构，描述了接口数据请求的规则</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Query 入口\ntype Query {\n    hello: String\n    users: [User]!\n    user(id: String): [User]!\n}\n\n# Mutation 入口\ntype Mutation {\n    createUser(id: ID!, name: String!, email: String!, age: Int,gender: Gender): User!\n    updateUser(id: ID!, name: String, email: String, age: Int, gender: Gender): User!\n    deleteUser(id: ID!): User\n}\n\n# Subscription 入口\ntype Subscription {\n    subsUser(id: ID!): User\n}\n\ntype User implements UserInterface {\n    id: ID!\n    name: String!\n    age: Int\n    gender: Gender\n    email: String!\n}\n\n# 枚举类型\nenum Gender {\n    MAN\n    WOMAN\n}\n\n# 接口类型\ninterface UserInterface {\n    id: ID!\n    name: String!\n    age: Int\n    gender: Gender\n}</code></pre></div>\n<p>在 Query 查询字段时，是并行执行的，而在 Mutation 变更的时候，是线性执行，一个接着一个</p>\n<h3>4.解析函数 Resolver</h3>\n<p>前端请求信息到达后端之后，需要由解析函数  Resolver  来提供数据\n解析函数接受四个参数：</p>\n<p>parent：当前上一个解析函数的返回值\nargs：查询中传入的参数\ncontext：提供给所有解析器的上下文信息\ninfo：一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值</p>\n<p>解析函数的返回值可以是一个具体的值，也可以是 Promise 或 Promise 数组。</p>","frontmatter":{"title":"react 与 typescript 学习资源汇总","date":"2022-01-26","description":null,"author":"谢玲玲"}},"previous":{"fields":{"slug":"/frontEnd/其他/less使用/"},"frontmatter":{"title":"less的使用"}},"next":{"fields":{"slug":"/frontEnd/其他/状态管理zustand/"},"frontmatter":{"title":"状态管理zustand"}}},"pageContext":{"id":"55ada83f-1871-5ed9-8c4a-140841254585","previousPostId":"d88a7a92-be9b-55b3-aeea-570cd2e8fc15","nextPostId":"6688c6f0-9493-5ec1-9ac1-3a60c2bec0a0"}},"staticQueryHashes":["2841359383","3257411868"]}