{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontEnd/其他/React与hooks学习/","result":{"data":{"site":{"siteMetadata":{"title":"HJGP技术知识库"}},"markdownRemark":{"id":"d1518997-e31c-5a9c-8dfe-20797a02fc9a","excerpt":"一、useState 1.1 定义 让函数组件中拥有 state 变量。它接收一个初始化的 state，返回是一个数组，数组里有两个元素，第一个元素是当前状态值和另一个更新该值的方法。\n​ 1.2 原理 返回是一个数组，利用解构赋值简化代码 ​ ​ 1.3 使用注意点 1、useState Hook…","html":"<h2>一、useState</h2>\n<h3>1.1 定义</h3>\n<p>让函数组件中拥有 state 变量。它接收一个初始化的 state，返回是一个数组，数组里有两个元素，第一个元素是当前状态值和另一个更新该值的方法。\n​</p>\n<h3>1.2 原理</h3>\n<p>返回是一个数组，利用解构赋值简化代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  //原始方式\n  const Message= () => {\n  const messageState = useState(\"\");\n  const message = messageState[0]; // 是一个空字符串\n  const setMessage = messageState[1]; // 是一个方法\n}\n\n //解构赋值\n  const Message = () => {\n  const [message, setMessage] = useState(\"\");\n}</code></pre></div>\n<p>​</p>\n<p>​</p>\n<h3>1.3 使用注意点</h3>\n<p>1、useState Hook 一次只能声明一个状态变量，这个状态变量可以是任意类型的。\n2、第一个参数 state 只能读，不能对它进行修改，例如：state++，state.splice 等操作。\n​</p>\n<p>​</p>\n<h3>1.4 使用场景</h3>\n<p>例 1：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//设定状态作为输入框的值\nconst [addInputValue,setAddInputValue]=useState('');\n&lt;input type=\"text\" value={addInputValue} onChange={(e)=>{setAddInputValue(e.target.value)}} placeholder=\"enter your todo\"/></code></pre></div>\n<h3></h3>\n<h2>二、路由传参方式</h2>\n<h3>2.1 Params 传参</h3>\n<p><strong>（1）在展示区域添加/:content</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Route path=\"/update/:content\" element={&lt;UpdateDome/>}>&lt;/Route></code></pre></div>\n<p><strong>（2）配置直接在路由拼接变量 content</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> navigate({ pathname: `./update/${JSON.stringify(item)}` })\n 或\n &lt;Link to={`./update/${JSON.stringify(things)}`}>点击跳转&lt;/Link></code></pre></div>\n<p><strong>（3）导入 useParams 获取传入的参数</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {useParams} from \"react-router-dom\";\nlet obj = useParams();\nconsole.log(obj.content);</code></pre></div>\n<p><strong>特点：</strong>\n1、需要路由配置\n2、刷新网页值还存在\n3、缺点：如果传参数过多，url 网址太长</p>\n<h3>2.2 query 传值</h3>\n<p><strong>（1）在路由上添加 pathname:‘/mine’路由地址 query:obj 对象形式传值</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Link to={{pathname:'/mine'}} query={{id:12}}>Mine&lt;/Link></code></pre></div>\n<p>​</p>\n<p><strong>（2）接收值在子展示页面使用</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">props.location.query.id</code></pre></div>\n<p>或</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {useLocation} from \"react-router-dom\";\nconst location=useLocation()\nlocation.query.id</code></pre></div>\n<p><strong>（3）query 的特点：</strong>\n​</p>\n<p>1、不需要配置路由\n2、刷新网页值被销毁\n3、可以传对象\n4、网页销毁后可以,存入 localstroge.setItme()或者 sessionstorage.setItme()进行存储,刷新可以从 localstroge 或者 sessionstorage 中获取\n​</p>\n<h3>2.3 state 方式传值</h3>\n<p><strong>（1）在路由上添加 pathname:‘/mine’路由地址 state:obj 对象形式传值</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Link to={{pathname:'/mine'}} state={{id:12}}>Mine&lt;/Link></code></pre></div>\n<p><strong>（2）接收值在子展示页面使用</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {useLocation} from \"react-router-dom\";\nconst location=useLocation()\nlocation.state.id</code></pre></div>\n<p>​</p>\n<p><strong>（3）state 的特点：</strong>\n​</p>\n<p>1、不需要配置路由\n2、刷新网页值不会被销毁\n3、可以传对象\n4、刷新网页值不会被销毁,，然而重新输入当前网址,网页的值会被销毁\n5、query 和 state 不会再 url 上显示,类似于 post，params 会在 url 上显示,类似于 get\n​</p>\n<p>​</p>\n<h2>三、组件传值</h2>\n<h3>3.1 父向子传值</h3>\n<p><strong>通过 props 传值，使用 useState 来控制 state 的状态值</strong>\n<strong>父组件 Father.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357322347-6a6aa996-db9e-4ac6-ad59-d359d768113f.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=ueb89f54f&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=307&#x26;originWidth=491&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=129216&#x26;status=done&#x26;style=none&#x26;taskId=u6ac2a786-0bf8-404c-8f98-8770befa830&#x26;title=\" alt=\"image.png\">\n<strong>子组件 Child.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357322465-1e92ee2f-7c74-4d7d-a892-77fd6fc6033b.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=uad1d6cd4&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=324&#x26;originWidth=464&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=98127&#x26;status=done&#x26;style=none&#x26;taskId=ucb6c03c1-128f-4f21-8b47-6071a7bb9a6&#x26;title=\" alt=\"image.png\"></p>\n<h4></h4>\n<h3>3.2 子向父传值</h3>\n<p><strong>像子组件传入回调函数，通过接收子组件的返回值，再去更新父组件的 state</strong>\n<strong>父组件，Father.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357411552-c7ef47df-ba0d-4367-b366-4474b1156fb2.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=ubf055df7&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=295&#x26;originWidth=581&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=127420&#x26;status=done&#x26;style=none&#x26;taskId=u48b04551-d493-4541-83ec-d1476f8ba18&#x26;title=\" alt=\"image.png\">\n<strong>子组件，Child.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357411912-e84cba28-139e-4e2a-9bc9-23a99f22232e.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=u074c0ddc&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=358&#x26;originWidth=534&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=147022&#x26;status=done&#x26;style=none&#x26;taskId=u907a2b19-0d53-4d5d-87a8-4585f9f272f&#x26;title=\" alt=\"image.png\"></p>\n<h4></h4>\n<h3>3.3 usecallback 优化子向父传值</h3>\n<p><strong>子传父优化版，使用 useCallback 存放处理事件的函数</strong>\n<strong>​</strong></p>\n<p><strong>父组件，Father.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357711497-81856fda-5c67-45d8-9b9c-4f32504aed32.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=ude53a58f&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=328&#x26;originWidth=762&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=187331&#x26;status=done&#x26;style=none&#x26;taskId=u7f5d1761-304c-40cc-a16f-66091cd0cc1&#x26;title=\" alt=\"image.png\"></p>\n<p><strong>子组件，Child.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357711501-ad4a46c0-9715-415f-95c0-6c7f1dde8f12.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=u2e160d1a&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=382&#x26;originWidth=635&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=176384&#x26;status=done&#x26;style=none&#x26;taskId=u0937c5b9-0e27-4fe1-8cac-02c3f23d4ad&#x26;title=\" alt=\"image.png\"></p>\n<h4></h4>\n<h3>3.4、useContext 父级向后代传值</h3>\n<p><strong>使用步骤：</strong></p>\n<ol>\n<li>创建 context</li>\n<li>使用 context.provider 关联需要传值的组件</li>\n<li>引入 context，和 useContext 并获取值</li>\n</ol>\n<p><strong>父组件，Father.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357796185-f9c268da-9b7d-4dd9-a8f3-4a63d85ca6c0.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=uc312efe6&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=410&#x26;originWidth=512&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=185568&#x26;status=done&#x26;style=none&#x26;taskId=u9fa4b114-37d1-4c9f-8d20-94389e8b486&#x26;title=\" alt=\"image.png\"></p>\n<p><strong>子组件，Child.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357795984-516fda34-b7c1-41c6-8c21-a8091701b5e7.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=uc725fbe5&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=332&#x26;originWidth=490&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=119054&#x26;status=done&#x26;style=none&#x26;taskId=uf70c9761-75f9-40e9-af82-53dc375bea4&#x26;title=\" alt=\"image.png\"></p>\n<p><strong>孙子组件，Sun.tsx 里：</strong>\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639357796087-616eb45a-0002-463c-a143-7fd823a6e0b5.png#clientId=u82eb03f1-a187-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;id=u74f0b8bf&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=248&#x26;originWidth=477&#x26;originalType=url&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=102421&#x26;status=done&#x26;style=none&#x26;taskId=u14f004e8-2f48-4de9-9433-3321359eb8e&#x26;title=\" alt=\"image.png\"></p>\n<h2>四、usememo</h2>\n<h3>4.1 语法格式</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);</code></pre></div>\n<h3>4.2 语法说明</h3>\n<p>它接受两个参数：</p>\n<ul>\n<li>第一个参数为回调函数（计算过程，必须返回一个结果）</li>\n<li>第二个参数是依赖项（数组），当依赖项中某一个发生变化，结果将会重新计算</li>\n</ul>\n<h3>4.3 作用</h3>\n<p>​</p>\n<p><strong>作用：</strong>\n把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。\n​</p>\n<h3>4.4 使用注意点</h3>\n<p><strong>注意：</strong></p>\n<ul>\n<li>传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</li>\n<li>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</li>\n<li>因为是缓存计算结果，所以参数 1 回调函数里面一定要有 return 返回值</li>\n</ul>\n<h3>4.5 案例</h3>\n<p>说明案例：通过 usememo 对 Calsum 的返回值进行缓存，达到只有 count 转态的值改变时，才会去执行 Calsum 函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    const [count, setcount] = useState(0);\n    const [otherCount, setotherCount] = useState(0);\n\n    const addCount = () => {\n        setcount(count + 1);\n    };\n\n    const addotherCount = () => {\n        setotherCount(otherCount + 1);\n    }\n\n    const Calsum = (count) => {\n        console.log(\"计算了count\");\n        let _sum = 0;\n        for (let i = 0; i &lt; count; i++) {\n            _sum += count;\n        }\n        return _sum;\n    }\n\n    // let sum = Calsum(count);\n    const sum = useMemo(() => { return Calsum(count) }, [count])\n\n    return (\n        &lt;div>\n            {sum}\n            &lt;div>&lt;button onClick={addCount}>+count&lt;/button>{count}&lt;/div>\n            &lt;div>&lt;button onClick={addotherCount}>+otherCount&lt;/button>{otherCount}&lt;/div>\n        &lt;/div>\n    )</code></pre></div>\n<h2>五、usecallback</h2>\n<h3>5.1 语法格式</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const memoizedCallback = useCallback(\n  () => {\n    doSomething(a, b);\n  },\n  [a, b],\n);</code></pre></div>\n<h3>5.2 语法说明</h3>\n<ul>\n<li>传递内联回调和依赖项数组。useCallback 将返回回调的记忆版本，该版本仅在依赖项之一发生更改时才会更改。这在将回调传递给依赖引用相等性的优化子组件时很有用，以防止不必要的渲染。</li>\n<li>useCallback(fn, deps)相当于 useMemo(() => fn, deps)。</li>\n</ul>\n<h3>5.3 案例</h3>\n<p>案例说明：把 fun 函数用 useCallback 缓存起来，防止每次刷新都重新赋值。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const CallbackDome=()=>{\n    const [value,setValue]=useState(1)\n    const fun=useCallback((code:number)=>{\n        setValue(code);\n    },[]);\n\n     return (\n         &lt;div>\n             父组件：\n             &lt;div>\n                 子组件：\n                &lt;SonDemo a={fun} b={value}/>\n             &lt;/div>\n         &lt;/div>\n     )\n }</code></pre></div>\n<p>​</p>\n<h2>六、useEffect</h2>\n<h3>6.1 语法格式</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(callback,deps)//（回调，依赖数组）</code></pre></div>\n<p>​</p>\n<h3>6.2 语法说明</h3>\n<p><strong>第一个参数:</strong>\n在组件发生 componentDidMount(组件加载结束) ， componentDidUpdate(状态变化) 和 componentWillUnmount(组件卸载)情况下都会触发 useEffect(函数参数)中函数参数的执行</p>\n<p><strong>第二个参数：</strong></p>\n<ol>\n<li>第二个参数是数组，数组中元素是状态变量， 当状态变量在其中才表示该状态被监听，没有在其中则不被监听.</li>\n<li>如果没有第二个参数，则默认所有状态都会被监。</li>\n<li>如果第二个参数是没有元素的数组，所有状态都不会被监听</li>\n</ol>\n<p><strong>作用:</strong>\nEffect Hook 可以让你在函数组件中执行副作用操作</p>\n<ul>\n<li>副作用:数据获取、设置/销毁定时器以及手动更改 React 组件中的 DOM 都属于副作用</li>\n<li>在函数组件中，每当 DOM 完成- -次渲染， 都会有对应的副作用执行</li>\n</ul>\n<h3>6.3 使用案例</h3>\n<h4>案例 1：只有一个回调的参数</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> useEffect(() => {\n\tconsole.log(\"useEffect()\")\n  })</code></pre></div>\n<h4>​</h4>\n<h4>案例 2：第二个参数依赖数组为空</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  const [num,setnum] = useState(0)\n\n  useEffect(()=>{\n        setInterval(()=>{\n            console.log(\"执行effect\");\n        },1000)\n    },[])\n\n    return (\n        &lt;div>\n\n        //这里依赖数组为空，可以实现点击button不会造成useeffect副作用函数的执行\n        &lt;button onClick={()=>{setnum(num+1)}}>num++&lt;/button>\n\n        &lt;/div>\n    )</code></pre></div>\n<h4>​</h4>\n<h4>案例 3：返回值销毁函数</h4>\n<p>一个实用的清除示例----定时器</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React,{useState, useEffect} from 'react';\n\nfunction App() {\n\tconst[name, setName] = useState&lt;string>(\"小王\");\n\tconst[age, setAge] = useState&lt;number>(20);\n\n\tfunction forEffect() {\n\n\t\tconsole.log(\"加载了App17\");\n\n\t\tlet id = setInterval(()=>{\n\t\t\tconsole.log(\"小王\");\n\t\t}, 1000);\n\n\t\t//从第二次执行useEffect开始，后面执行都先执行return返回的函数\n\t\treturn ()=>{\n\t\t\tconsole.log(\"清楚\");\n\t\t\tclearInterval(id);\n\t\t}\n\t}\n\n\tuseEffect(forEffect, [name, age]);\n\n\treturn(\n\t\t&lt;div>\n\t\t\t{name},{age}\n\t\t\t&lt;button onClick={()=>{setName(\"小王\"+ Math.floor(Math.random()*100))  }}>改变状态name&lt;/button>\n\t\t\t&lt;button onClick={()=>{setAge(Math.floor(Math.random()*100)) }}>改变状态age&lt;/button>\n\t\t&lt;/div>\n\t);\n}\n\nexport default App;</code></pre></div>\n<h3>6.4 useEffect 在组件中执行的顺序</h3>\n<p>​</p>\n<p>每次副作用执行，都会返回个新的销毁函数\n销毁函数会在下一个副作用逻辑之前执行(DOM 渲 染之后)\n组件销毁也会执行销毁函数\n<img src=\"https://cdn.nlark.com/yuque/0/2021/png/25568957/1639385314664-b404b874-38d4-4002-b6ee-de3f6014718e.png#clientId=u3305af55-f672-4&#x26;crop=0&#x26;crop=0&#x26;crop=1&#x26;crop=1&#x26;from=paste&#x26;height=303&#x26;id=ueb4df2a9&#x26;margin=%5Bobject%20Object%5D&#x26;name=image.png&#x26;originHeight=606&#x26;originWidth=1517&#x26;originalType=binary&#x26;ratio=1&#x26;rotation=0&#x26;showTitle=false&#x26;size=285318&#x26;status=done&#x26;style=none&#x26;taskId=ua54c4f0b-b5ae-4db8-85cc-787ce18240f&#x26;title=&#x26;width=758.5\" alt=\"image.png\">\n​</p>\n<h2>七、useContext</h2>\n<h3>7.1 定义</h3>\n<p>useContext 可以实现父组件向后代组件传值,(后代组件指子代，孙代，再下一代…)</p>\n<h3>7.2 使用</h3>\n<p>1、创建 ThemeContext, 最好写成一个独立的文件，因为该对象要被公用的。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nconst Themecontext = React.createContext&lt;any>(null);\nexport default Themecontext;</code></pre></div>\n<p>​</p>\n<p>2、使用 ThemeContent.Provider 的属性 value 设置数据，把子组件位于 ThemeContent.Provider 标签中.\n​</p>\n<p>father.tsx</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return (\n        &lt;Themecontext.Provider value={{name,handelname,setname}}>\n             &lt;div style={{border:\"1px solid yellow\"}}>这是父亲组件\n        &lt;Child/>\n        &lt;Child2/>\n        &lt;/div>\n        &lt;/Themecontext.Provider>\n\n    )</code></pre></div>\n<p>3、后代组件中使用 useContext 得到 Provider 中 value 的值。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const formation = React.useContext(Themecontext)</code></pre></div>\n<h3>7.3 实现子向父传值</h3>\n<p>让父组件的 ThemeContext.Provider 中 value 的值产生改变，进而触使父组件的所有子代组件全部刷新。具体实现可以把父组件中修改状态的函数和状态本身封装在一个对象中，然后把该对象当成&#x3C;ThemeContext.Provider value={????}>中 value 的值传递后代组件，后代组件取出对象，再从对象中取出函数和状态，后代组件就可以调用取出的函数了，进行可以调用函数，调用该函数就可以修改状态的值了\n​</p>\n<p><strong>father.tsx:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React from \"react\";\nimport Child from \"./Child\";\nimport Child2 from \"./Child\";\nimport Themecontext from \"./Themecontext\"\nfunction UsecontextDom(){\n    const [name,setname] = React.useState&lt;string>(\"--李畅\");\n     function handelname(name:string) {\n        setname(name);\n    };\n    return (\n        &lt;Themecontext.Provider value={{name,handelname,setname}}>\n             &lt;div style={{border:\"1px solid yellow\"}}>这是父亲组件\n        &lt;Child/>\n        &lt;Child2/>\n        &lt;/div>\n        &lt;/Themecontext.Provider>\n\n    )\n}\nexport default UsecontextDom;</code></pre></div>\n<p><strong>child.tsx:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const formation = React.useContext(Themecontext)\n  return (\n        &lt;div style={{border:\"1px solid yellow\"}}>这是儿子组件\n          &lt;p>获取到父组件中的转态{formation.name}&lt;/p>\n          &lt;button onClick={formation.handelname.bind(null,\"--张张\")}>修改父组件的name&lt;/button>\n          &lt;button onClick={formation.setname.bind(null,\"--嘻哈\")}>修改父组件的setname()&lt;/button>\n          &lt;/div>\n\n    )</code></pre></div>\n<h3></h3>\n<h2>八、useReducer</h2>\n<p>useReducer 与 useState 的相同点：都是对状态的管理，状态的使用是完全相同的\n可以说 useReducer 能实现的功能与 useState 是完全相同的。\n​</p>\n<p>但是站在代码设计的角度上看，useReducer 部分代替 useState 时，比 useState 要更合适一些。\n​</p>\n<p>1、导入 useReducer</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import React,{useReducer} from \"react\";</code></pre></div>\n<p>2、定义 useReducer</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//state:是上一次状态的值,所以state数据类型与返回值类型应该一样\nfunction reducer(state :humber, action:string) :number {\n   console. log(state, action);//100 \"你好世界\"\n   return 1000;\n   }</code></pre></div>\n<p>3、在定义前写好函数</p>\n<p>(1)当主动调用 dispatch 函数时会触发 reducer 函数的执行\n(2)形参 state:接收上一-次状态值\n(3)形参 action:接收调用 dispatch 函数时传递的实参值\n(4)函数 reducer 的返回值成为状态 state 的新值，进而触发组件更新，也会触发 useEffect 执行\n(5)参数的类型是按照状态和 dispatch 的实参来确定的</p>\n<h2>十、自定义 hooks</h2>\n<p>** 定义:**\n除了使用内置的 Hooks 之外，还可以自定义 Hooks，自定义 Hooks 针对不同组件实现不同状态逻辑复用。\n​</p>\n<p><strong>使用规范：</strong>\n<strong>​</strong></p>\n<ul>\n<li>\n<p>自定义 Hooks 是一个函数，约定函数名称必须以 use 开头，React 就是通过函数名称是否以 use 开头来判断是不是 Hooks。</p>\n</li>\n<li>\n<p>Hooks 只能在函数组件中或其他自定义 Hooks 中使用，否则，会报错！</p>\n</li>\n<li>\n<p>自定义 Hooks 用来提取组件的状态逻辑，根据不同功能可以有不同的参数和返回值（就像使用普通函数一样）</p>\n</li>\n</ul>\n<p>​</p>\n<p><strong>使用场景:</strong>\n将组件状态逻辑提取到可重用的函数（自定义 Hooks）中，实现状态逻辑复用。\n对业务，功能进行抽离的时候。\n<strong>​</strong></p>\n<p>​</p>\n<h3>1、useTitle</h3>\n<h4>1.1 完成效果</h4>\n<p>使用 useTitle 去修改标题\n​</p>\n<h4>1.2 实现思路</h4>\n<ol>\n<li>使用时，应该传入一个修改标题的参数值</li>\n<li>然后对参数进行操作</li>\n<li>使用 useEffect 对操作何时更新进行控制</li>\n</ol>\n<p>​</p>\n<h4>1.3 useTittle 实现代码</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useTitle = (value:string)=>{\n    useEffect(()=>{\n        document.title=value;\n    },[value])\n}</code></pre></div>\n<h3></h3>\n<h3>2、防抖</h3>\n<h4>2.1 需要改进的地方</h4>\n<p>第一次触发时，不进行防抖处理\n​</p>\n<h4>2.2 实现思路</h4>\n<p>​</p>\n<ol>\n<li>至少需要传入两个，事件处理函数，和需要延迟的时间</li>\n<li>保存定时器，当第一次触发时执行定时器</li>\n<li>在延迟时间内再次触发则清楚定时器</li>\n</ol>\n<p>​</p>\n<h4>2.3 useDebounce 实现代码</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useDebounce = (fun: Function, delay: number) => {\n  const time1 = useRef&lt;any>(null);\n  const first = useRef&lt;boolean>(true);\n  return useCallback(() => {\n    if (time1.current) {\n      clearTimeout(time1.current);\n    }\n    if (first.current) {\n      fun();\n      first.current = false;\n    } else {\n      time1.current = setTimeout(() => {\n        fun();\n      }, delay)\n    }\n\n\n  }, [fun, delay])\n}</code></pre></div>\n<h3>3、节流</h3>\n<h4>3.1 需要改进的地方</h4>\n<p>第一次触发时，不进行节流处理\n<strong>​</strong></p>\n<h4>3.2 实现思路</h4>\n<p><strong>​</strong></p>\n<ol>\n<li>至少需要传入两个，事件处理函数，和需要延迟的时间</li>\n<li>保存定时器，当第一次触发时执行定时器</li>\n<li>在延迟时间内再次触发则直接返回，不做处理</li>\n</ol>\n<p>​</p>\n<h4>3.3 useThrottle 实现代码</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useThrottle = (fun: Function, delay: number) => {\n  const time1 = useRef&lt;any>(null);\n  const throttle = useCallback(() => {\n    if (time1.current) {\n      return;\n    }\n    time1.current = setTimeout(() => {\n      fun();\n      time1.current = null;\n    }, delay)\n  }, [delay, fun])\n  return throttle</code></pre></div>\n<h3>4、屏幕高度 hooks</h3>\n<h4>4.1 需要改进的地方</h4>\n<p>结合节流去获取屏幕高度</p>\n<h4>4.2 实现思路</h4>\n<ol>\n<li>返回值为当前屏幕高度</li>\n<li>当调用 useScreenHight 时就开始进行监听屏幕高度</li>\n<li>屏幕高度的改变用一个状态去保存</li>\n</ol>\n<h4>4.3 useScreenHight 实现代码</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useScreenheight = () => {\n    const [height, setheight] = useState(document.documentElement.clientHeight);\n\n    const handelSize = useCallback(() => {\n        setheight(document.documentElement.clientHeight);\n    }, []);\n\n    useEffect(() => {\n        window.addEventListener(\"resize\", handelSize);\n        // 为了防止一直监听所以在方法移除时，使用return的方式移除监听\n        return () => {\n            window.removeEventListener(\"resize\", handelSize)\n        }\n    }, [])\n    return height;\n}</code></pre></div>\n<p>​</p>\n<h3>5、倒计时</h3>\n<h4>5.1 需要改进的地方</h4>\n<p>对倒计时应该有，开始，暂停，重新开始计时的功能\n倒计时为 0 时，可以进行有一些操作</p>\n<h4>5.2 实现思路</h4>\n<ol>\n<li>传入倒计时总长度</li>\n<li>定义一个倒计时函数</li>\n<li>把当前时间和回调函数传出</li>\n<li>调用 useDownCount 是可以解构到时间和触发倒计时的函数</li>\n</ol>\n<h4>5.3 useDownCount 实现代码</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useCountdown = (initcount: number) => {\n  const [count, setcount] = useState(initcount);\n  let time1: any = null;\n  const handleCount = () => {\n    setcount(initcount)\n    time1 = setInterval(() => {\n      setcount((count) => count - 1)\n    }, 1000)\n  }\n  useEffect(() => {\n    return () => {\n      clearInterval(time1)\n    }\n  }, [])\n\n  return {\n    count,\n    handleCount\n  }\n}\n</code></pre></div>\n<h2>十一、路由使用跳转</h2>\n<h4>11.1 环境</h4>\n<p>1、下载第三方模块：react-router-dom；\n2、引入：import {BrowserRouter as Router,Routes,Route} from ‘react-router-dom’；\n3、使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;Router>\n        &lt;Routes>\n            &lt;Route path=\"/\" element={&lt;Main/>}>&lt;/Route>\n            &lt;Route path=\"/update/:content\" element={&lt;UpdateDome/>}>&lt;/Route>\n        &lt;/Routes>\n    &lt;/Router></code></pre></div>\n<h4></h4>\n<h4>11.2 实现跳转</h4>\n<p><strong>1、link</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//使用\n&lt;Link to={{ pathname: \"/second\"}}> Link进入second &lt;/Link></code></pre></div>\n<p><strong>2、useNavigate</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//导入\nimport { useNavigate } from 'react-router-dom';\n\n//得到navigate返回值\n const navigate = useNavigate();\n\n //实现路由跳转\n navigate({ pathname: `./update/${JSON.stringify(item)}` })</code></pre></div>\n<h2>十二、路由传参 useparams</h2>\n<p>使用：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//路由路径中加 :参数名\n&lt;Route path=\"/update/:content\" element={&lt;UpdateDome/>}>&lt;/Route>\n\n//跳转时添加参数\n navigate({ pathname: `./update/${JSON.stringify(item)}` })\n\n //导入\n import {  useNavigate,useParams} from \"react-router-dom\";\n\n //获取参数\n let obj = useParams();\n let content = JSON.parse(obj.content).thing;</code></pre></div>\n<h4></h4>\n<h2></h2>\n<p>​</p>","frontmatter":{"title":"react学习笔记","date":"2022-01-26","description":null,"author":"chang"}},"previous":{"fields":{"slug":"/frontEnd/其他/Gatsby/"},"frontmatter":{"title":"Gatsby学习笔记"}},"next":{"fields":{"slug":"/frontEnd/其他/git的使用/"},"frontmatter":{"title":"git的使用"}}},"pageContext":{"id":"d1518997-e31c-5a9c-8dfe-20797a02fc9a","previousPostId":"4b111c0c-c9b6-5dae-95b3-3f1414abd558","nextPostId":"c086ef4e-5a50-5d31-9931-29cd3848dd9c"}},"staticQueryHashes":["2841359383","3257411868"]}