{"componentChunkName":"component---src-templates-blog-post-js","path":"/frontEnd/其他/调试分享/","result":{"data":{"site":{"siteMetadata":{"title":"HJGP技术知识库"}},"markdownRemark":{"id":"bb5a4749-6a7d-5341-8b0f-82daa0be83de","excerpt":"1、什么是调试？ 代码在某个平台运行，把运行时的状态通过某种方式暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。 这里的某个平台，可以是 、 、  、 等任何能执行 JS…","html":"<h1>1、什么是调试？</h1>\n<p>代码在某个平台运行，把运行时的状态通过某种方式暴露出来，传递给开发工具做 UI 的展示和交互，辅助开发者排查问题、梳理流程、了解代码运行状态等，这个就是调试。</p>\n<p>这里的某个平台，可以是 <code class=\"language-text\">浏览器</code>、<code class=\"language-text\">Node.js</code> 、 <code class=\"language-text\">Electron</code> 、 <code class=\"language-text\">小程序</code>等任何能执行 JS 代码的平台。</p>\n<p>暴露出的运行时状态，可能是<code class=\"language-text\">调用栈、执行上下文，或者 DOM 的结构，React 组件的状态</code>等。</p>\n<p>暴露出这些数据的方式一般是通过基于 <code class=\"language-text\">WebSocket</code> 的调试协议，当然也会有别的方式（一些自定义协议之类的）。</p>\n<h1>2、一些调试的理论知识</h1>\n<p>对于调试来说有两个东西是绕不开的，一个是 <code class=\"language-text\">SourceMap</code>的原理，一个是调试的原理。</p>\n<h2>2.1、sourcemap 原理</h2>\n<p>回到过去，我们使用纯 <code class=\"language-text\">HTML</code>、<code class=\"language-text\">CSS</code> 和 <code class=\"language-text\">JavaScript</code> 构建 <code class=\"language-text\">Web 应用程序，并将它们部署到 Web</code>上去。</p>\n<p>然而，随着我们如今构建更复杂的 <code class=\"language-text\">Web</code> 应用程序，我们的开发工作流程可能涉及使用各种工具。例如：</p>\n<ul>\n<li>模版语法和 <code class=\"language-text\">HTML预处理器</code></li>\n<li>Css 预处理器</li>\n<li><code class=\"language-text\">JavaScript</code> 框架</li>\n<li>元框架</li>\n<li>高级编程语言</li>\n</ul>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16811999563619.jpg\" alt=\"\"></p>\n<p>这些工具需要一个构建过程来将您的代码转换为浏览器可以理解的标准 <code class=\"language-text\">HTML</code>、<code class=\"language-text\">JavaScript</code> 和 <code class=\"language-text\">CSS</code>。此外，为了优化性能，通常的做法是压缩代码，然后组合起来，减小代码的大小提高效率。</p>\n<p>举个例子，使用打包构建工具，将下面的代码压缩。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token literal-property property\">num</span><span class=\"token operator\">:</span> number <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">101</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token literal-property property\">greet</span><span class=\"token operator\">:</span> string <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLParagraphElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerText <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>greet<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, you are no. </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>num<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>压缩后：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"button\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"click\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> e <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token number\">101</span> <span class=\"token operator\">*</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>innerText <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, you are no. </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>e<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但是，这种优化会使调试更具挑战性。将所有内容都集中在一行中的压缩代码和较短的变量名称会使查明问题的根源变得困难。这就是源映射的用武之地——它们将编译后的代码映射回原始代码。</p>\n<hr>\n<p>因此学习调试，<code class=\"language-text\">sourcemap</code> 是绕不开的概念，有了它才能清晰调试源码，<code class=\"language-text\">sourcemap</code>以 <code class=\"language-text\">.map</code>结。\n例如<code class=\"language-text\">example.min.js.map</code>、<code class=\"language-text\">styles.css.map</code>。</p>\n<p><code class=\"language-text\">sourcemap</code> 是关联编译后的代码和源码的，通过一个个行列号的映射。</p>\n<p><code class=\"language-text\">sourcemap</code> 只是位置的映射，可以用在任何代码上，比如 <code class=\"language-text\">JS、TS、CSS</code> 等，而且 <code class=\"language-text\">TS</code> 的类型也支持 <code class=\"language-text\">sourcemap</code>。</p>\n<p>我们可以看一下就是我们代码里的生成的 <code class=\"language-text\">sourcemap</code> 文件是怎样的。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n　　　 version : 3,\n　　　 file: \"xxx.js\",\n　　　 sourceRoot : \"\",\n　　　 sources: [\"foo.js\", \"bar.js\"],\n　　　 names: [\"a\", \"b\"],\n　　　 mappings: \"AAgBC,SAAQ,CAAEA;AAAEA\",\n      sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']\n}</code></pre></div>\n<ul>\n<li><strong>version</strong>：sourcemap 的版本，一般为 3</li>\n<li><strong>file</strong>：编译后的文件名</li>\n<li><strong>sourceRoot</strong>：源码根目录</li>\n<li><strong>names</strong>：转换前的变量名</li>\n<li><strong>sources</strong>：源码文件名</li>\n<li><strong>sourcesContent</strong>：每个 sources 对应的源码的内容</li>\n<li><strong>mappings</strong>：一个个位置映射</li>\n</ul>\n<p><a href=\"https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1\">文档在这</a></p>\n<p><code class=\"language-text\">mappings</code> 部分是通过分号; 和逗号 , 分隔的：</p>\n<p><code class=\"language-text\">mappings:\"AAAAA,BBBBB;CCCCC\"</code></p>\n<p>一个分号就代表一行，这样就免去了行的映射。</p>\n<p>然后每一行可能有多个位置的映射，用 , 分隔。</p>\n<p>那具体的每一个 <code class=\"language-text\">mapping</code> 都是啥呢？</p>\n<p>比如 <code class=\"language-text\">AAAAA</code> 一共五位，分别有不同的含义：</p>\n<ul>\n<li>转换后代码的第几列（行数通过分号 ; 来确定）</li>\n<li>转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引</li>\n<li>转换前的源码的第几行</li>\n<li>转换前的源码的第几列</li>\n<li>转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引</li>\n</ul>\n<p>我们可以通过这个可视化的<a href=\"https://sokra.github.io/source-map-visualization/\">代码分析</a>和<a href=\"https://evanw.github.io/source-map-visualization/\">上传 map</a>，来分析调试文件。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16812005976010.jpg\" alt=\"\"></p>\n<p>然后经过编码之后，就成了 <code class=\"language-text\">AAAAA</code> 这种，这种编码方式叫做 <code class=\"language-text\">VLQ</code> 编码。</p>\n<p><code class=\"language-text\">sourcemap</code> 的格式还是很容易理解的，就是一一映射编译后代码的位置和源码的位置。</p>\n<p>各种调试工具一般都支持 <code class=\"language-text\">sourcemap</code> 的解析，只要在文件末尾加上这样一行：</p>\n<p><code class=\"language-text\">//# sourceMappingURL=/path/to/source.js.map</code></p>\n<h2>2.2 sourcemap 通信原理</h2>\n<p>那么当我们看完这个就紧接着讲到调试工具和调试协议的事情了，而 <code class=\"language-text\">Chrome DevTools</code>是我们最常遇到的调试工具。</p>\n<p><code class=\"language-text\">Chrome DevTools</code> 分为两部分，<code class=\"language-text\">backend</code> 和 <code class=\"language-text\">frontend</code>：</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16808297647763.jpg\" alt=\"\"></p>\n<p><code class=\"language-text\">backend</code> 是 <code class=\"language-text\">Chrome</code> 集成的，负责把 <code class=\"language-text\">Chrome</code> 的网页运行时状态通过调试协议暴露出来。</p>\n<p><code class=\"language-text\">frontend</code> 是独立的，负责对接调试协议，做 <code class=\"language-text\">UI</code> 的展示和交互。</p>\n<p>两者之间的调试协议叫做 <code class=\"language-text\">Chrome DevTools Protocol</code>，简称 <code class=\"language-text\">CDP</code>。</p>\n<p>传输协议数据的方式叫做信道（message channel），有很多种，比如 <code class=\"language-text\">Chrome DevTools</code> 嵌入在 Chrome 里时，两者通过全局的函数通信；当 <code class=\"language-text\">Chrome DevTools</code> 远程调试某个目标的代码时，两者通过 <code class=\"language-text\">WebSocket</code> 通信。</p>\n<p><code class=\"language-text\">frontend、backend、调试协议（CDP）、信道</code>，这是 <code class=\"language-text\">Chrome DevTools</code> 的 4 个组成部分。</p>\n<p>那么我们可以举一反三，对于大部分主流调试插件，就像是<code class=\"language-text\">Chrome DevTools、VSCode Debugger、Vue/React DevTools</code>这些来说。</p>\n<p>他们都有相似的架构，也就是四要素</p>\n<ul>\n<li><strong>frontend</strong>: 负责交互和渲染。</li>\n<li><strong>backend</strong>: 负责拿到运行时信息。</li>\n<li><strong>调试协议</strong>：规定不同数据的格式。</li>\n<li><strong>信道</strong>：传输协议数据。</li>\n</ul>\n<h2>2.3、关于 vscode 调试</h2>\n<p><code class=\"language-text\">VSCode Debugger</code> 的原理和 <code class=\"language-text\">Chrome DevTools</code> 差不多，也是分为 <code class=\"language-text\">frontend</code>、<code class=\"language-text\">backend</code>、<code class=\"language-text\">调试协议</code>这几部分，只不过它多了一层<code class=\"language-text\">适配器协议</code>。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813535357882.jpg\" alt=\"\"></p>\n<p>为了能直接用 <code class=\"language-text\">Chrome DevTools</code> 调试 <code class=\"language-text\">Node.js</code> 代码，<code class=\"language-text\">Node.js 6</code> 以上就使用 <code class=\"language-text\">Chrome DevTools Protocol</code> 作为调试协议了，所以 <code class=\"language-text\">VSCode Debugger</code> 要调试 <code class=\"language-text\">Node.js</code> 也是通过这个协议。</p>\n<p>但是中间多了一层适配器协议 <code class=\"language-text\">Debug Adapter Protocol</code>，这是为什么呢？</p>\n<p>因为 <code class=\"language-text\">VSCode</code> 不是 <code class=\"language-text\">JS</code> 专用编辑器，它可能用来调试 <code class=\"language-text\">Python</code> 代码、<code class=\"language-text\">Rust</code> 代码等等，自然不能和某一种语言的调试协议深度耦合，所以多了一个适配器层。</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813535780390.jpg\" alt=\"\"></p>\n<p>这样 <code class=\"language-text\">VSCode Debugger</code> 就可以用同一套 <code class=\"language-text\">UI</code> 和逻辑来调试各种语言的代码，只要对接不同的 <code class=\"language-text\">Debug Adapter</code> 做协议转换即可。</p>\n<p>这样还有另一个好处，就是别的编辑器也可以用这个 <code class=\"language-text\">Debug Adapter Protocol</code> 来实现调试，这样就可以直接复用 <code class=\"language-text\">VSCode</code> 的各种语言的 <code class=\"language-text\">Debug Adapter</code> 了。</p>\n<p><code class=\"language-text\">VSCode Debugger</code> 的 <code class=\"language-text\">UI</code> 的部分算是 <code class=\"language-text\">frontend</code>，而调试的目标语言算是 <code class=\"language-text\">backend</code> 部分，中间也是通过 <code class=\"language-text\">WebSocket</code> 传递调试协议。</p>\n<p>整体和 <code class=\"language-text\">Chrome DevTools</code> 的调试原理差不多，只不过为了支持 <code class=\"language-text\">frontend</code> 的跨语言复用，多了一层适配器层。</p>\n<hr>\n<p>然后我们讲点 <code class=\"language-text\">vscode</code> 调试里的东西。</p>\n<h1>3、对于调试的最佳实践和 sourcemap 配置</h1>\n<h2>3.1、Sourcemap 配置以及断点类型</h2>\n<h3>3.1.1、Sourcemap 配置</h3>\n<p>对于调试来说有很多不同的配置，但其实这事我们不用细记，看文档就可以很好的挑选我们的生成<code class=\"language-text\">soucemap</code>的配置。</p>\n<ul>\n<li><strong>eval</strong>：浏览器 <code class=\"language-text\">devtool</code> 支持通过 <code class=\"language-text\">sourceUrl</code> 来把 <code class=\"language-text\">eval</code> 的内容单独生成文件，还可以进一步通过 <code class=\"language-text\">sourceMappingUrl</code> 来映射回源码，<code class=\"language-text\">webpack</code> 利用这个特性来简化了 <code class=\"language-text\">sourcemap</code> 的处理，可以直接从模块开始映射，不用从 <code class=\"language-text\">bundle</code> 级别。</li>\n<li><strong>cheap</strong>：只映射到源代码的某一行，不精确到列，可以提升 <code class=\"language-text\">sourcemap</code> 生成速度</li>\n<li><strong>source-map</strong>：生成 <code class=\"language-text\">sourcemap</code> 文件，可以配置 <code class=\"language-text\">inline</code>，会以 <code class=\"language-text\">dataURL</code> 的方式内联，可以配置 <code class=\"language-text\">hidden</code>，只生成 <code class=\"language-text\">sourcemap</code>，不和生成的文件关联</li>\n<li><strong>nosources</strong>：不生成 <code class=\"language-text\">sourceContent</code> 内容，可以减小 <code class=\"language-text\">sourcemap</code> 文件的大小</li>\n<li><strong>module</strong>： <code class=\"language-text\">sourcemap</code> 生成时会关联每一步 <code class=\"language-text\">loader</code> 生成的 <code class=\"language-text\">sourcemap</code>，可以映射回最初的源码</li>\n</ul>\n<h3>3.1.2、断点类型、调试窗</h3>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813824663362.jpg\" alt=\"\"></p>\n<ul>\n<li>继续(F5)、</li>\n<li>调试下一步(F10)、</li>\n<li>单步跳入(F11)、</li>\n<li>单步跳出(Shift F11)、</li>\n<li>重新调试(Ctrl + Shift + F5)、</li>\n<li>结束调试(Shift + F5)</li>\n</ul>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813824004284.jpg\" alt=\"\">\n分别解释一下：</p>\n<ol>\n<li>正常的断点</li>\n<li>记录点又称为日志断点，日志断点是普通断点的一种变体，区别在于不会中断调试，而是可以把信息记录到控制台。日志断点对于调试无法暂停或停止的服务时特别有用。</li>\n</ol>\n<p>添加记录点\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813826527727.jpg\" alt=\"\"></p>\n<p>按回车会有一个菱形的标识\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813826682929.jpg\" alt=\"\"></p>\n<p>3.条件断点又可以分为三类\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813828657841.jpg\" alt=\"\"></p>\n<p><strong>表达式</strong>：就像是这样<code class=\"language-text\">Components.name.includes('input')</code>，当组件名字包含<code class=\"language-text\">input</code>会断住。</p>\n<p><strong>命中次数</strong>：这个很好理解，比如<code class=\"language-text\">>10</code>，跑这个地方跑了 11 次他就断住了。</p>\n<p><strong>日志消息</strong>：和日志断点很像但他会断住并打印。</p>\n<hr>\n<p>大概就到这，有些奇妙的断点得自己细细体悟。</p>\n<h2>3.2、对于 Web 如何挑选合适的调试配置</h2>\n<ul>\n<li><code class=\"language-text\">type</code>: 就分成<code class=\"language-text\">chore</code>和<code class=\"language-text\">node</code>就好</li>\n<li><code class=\"language-text\">requset</code>:一般来说如果是希望直接打开一个调试浏览器并定位到你的页面，直接就使用<code class=\"language-text\">launch</code>就好，而对于你想链接的已经打开在调试浏览器的页面就使用<code class=\"language-text\">attach</code></li>\n<li><code class=\"language-text\">userDataDir</code>:这个配置默认是<code class=\"language-text\">true</code>，会打开一个并没有带有你用户信息的调试浏览器。而如果你选择<code class=\"language-text\">false</code>，会使用默认的<code class=\"language-text\">user data dir </code>，也就是保存用户数据的地方，比如你的浏览记录、cookies、插件、书签、网站的数据等等，在 macOS 下是保存在这个位置<code class=\"language-text\">~/Library/Application\\ Support/Google/Chrome</code>,这就是看你需不需要你的你本地的用户信息了。</li>\n<li><code class=\"language-text\">runtimeExecutable</code>: web 下这个配置针对的是浏览器。</li>\n<li><code class=\"language-text\">sourceMapPathOverrides</code>: 对<code class=\"language-text\">Sourcemap</code>做一次映射，就如图所示，它是针对路径的（正常来说我们开发用不到这个配置，因为那种不可读的文件你改了也没啥用，只有在一些那种直接在线上调试可以用到这个配置把路径映射到本地的代码）。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-1-.png\" alt=\"未命名文件 -1-\">通常针对于一些在内存中的文件（此时只读）因为并没有在本地目录下所有不可编辑，比如这样\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813940750994.jpg\" alt=\"\">\n下面的配置项中有默认有这么三个配置，分别是把 <code class=\"language-text\">meteor、webpack</code> 开头的 <code class=\"language-text\">path</code> 映射到了本地的目录下。</li>\n</ul>\n<p>其中 <code class=\"language-text\">?:*</code> 代表匹配任意字符，但不映射，而 <code class=\"language-text\">* </code>是用于匹配字符并映射的。</p>\n<p>比如最后一个 <code class=\"language-text\">webpack://?:*/*</code> 到 <code class=\"language-text\">${workspaceFolder}/*</code> 的映射，就是把 <code class=\"language-text\">webpack://</code> 开头，后面接任意字符 + / 然后是任意字符的路径映射到了本地的项目目录。（workspaceFolder 是一个内置变量，代表项目根目录）</p>\n<ul>\n<li><code class=\"language-text\">runtimeArgs</code>：启动浏览器的时候传递的启动参数这个得看看谷歌浏览器的配置了。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"chrome\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// launch或者attch 分别是以调试模式启动浏览器/链接某个在调试模式启动URL通过端口号链接</span>\n  <span class=\"token property\">\"request\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"launch\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 打开的地址</span>\n  <span class=\"token property\">\"url\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://localhost:3014\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 要不要使用默认的用户信息</span>\n  <span class=\"token property\">\"userDataDir\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 启动调试的浏览器名称</span>\n  <span class=\"token property\">\"runtimeExecutable\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"stable\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 启动浏览器的时候传递的启动参数</span>\n  <span class=\"token property\">\"runtimeArgs\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 对 sourcemap 到的文件路径做一次映射，映射到 VSCode workspace 下的文件，这样调试的文件就可以修改了</span>\n  <span class=\"token property\">\"sourceMapPathOverrides\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"meteor://💻app/*\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${workspaceFolder}/*\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack:///./~/*\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${workspaceFolder}/node_modules/*\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"webpack://?:*/*\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${workspaceFolder}/*\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">//可以直接指定某个文件，然后启动调试</span>\n  <span class=\"token property\">\"file\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${workspaceFolder}/index.html\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">//就你这段调试名称的名字</span>\n  <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"attach Chrome against localhost\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// 根路径</span>\n  <span class=\"token property\">\"webRoot\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"${workspaceFolder}\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>3.3、简单的调试表层业务代码</h2>\n<p>假设此时我们有这样一个场景，我有一个 BUG，这时候我感觉我的<code class=\"language-text\">exportParms</code>有问题。\n图 1：\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813795245544.jpg\" alt=\"\">\n图 2：\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813791763625.jpg\" alt=\"\"></p>\n<p>在这段代码中我需要知道<code class=\"language-text\">exportParms</code>、 <code class=\"language-text\">reqBillStatus</code>、 <code class=\"language-text\">BillStatusEnum</code> 、 <code class=\"language-text\">hasSelectionAndUnReviewedStatus</code>的状态，那我分别需要在<code class=\"language-text\">useFormatParams</code>里去看这个对象是怎么抛出来的，去进行一大堆打印、再在<code class=\"language-text\">231</code>行打印他们的状态。</p>\n<p>那么如果我学会在 Vscode 里打断点，我们在<code class=\"language-text\">图1</code>的<code class=\"language-text\">68</code>行，<code class=\"language-text\">图2</code>的<code class=\"language-text\">376</code>行打 2 个断点我们就可以完成上述一系列复杂的过程，我甚至不需要在浏览器里打开<code class=\"language-text\">F12</code>就已经完成了整个查看的过程。</p>\n<p>我们在<code class=\"language-text\">68</code>行打个断点<code class=\"language-text\">F11</code>单独调试就进入到这个<code class=\"language-text\">useFormatParams</code>这个函数中，之后就是这个自定义<code class=\"language-text\">hook</code>的调试观察，此时如果我们不想关心这些逻辑，我们只想关心<code class=\"language-text\">exportParams</code>这个参数，可以把它调到监视面板（就是实时监听变量的变化）中。</p>\n<p>监视面板对于我们实战最大的意义就是可以很方便的把一个你始终需要看到的变量从不同的上下文中提取出来进行一个查看的操作。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813800476412.jpg\" alt=\"\"></p>\n<p>接下来，直接放开断点跳到上面说到的<code class=\"language-text\">376</code>行。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813812395909.jpg\" alt=\"\">\n此时所有你需要的信息都肉眼可见，那是否是很方便那？</p>\n<p>当然这个场景还是有点过于简单了，我所指的复杂场景是，假设有一个大量计算和众多的复杂业务逻辑的组件、他们的状态会相互影响、一个函数就会牵动大批量逻辑的时候，那此时的调试就能很方便的帮你理清上下文和整体的业务逻辑，就我实在是没找到那种过于复杂的业务场景（才来对业务有点不熟悉还是）。</p>\n<h2>3.3、稍微进阶一点的调试</h2>\n<p>那么如果说我感觉我代码里的组件有问题，它有可能来自其他组件库，就类似<code class=\"language-text\">ant</code>这样我们该如何调试那？</p>\n<p>OK!我们直接开始\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813844421824.jpg\" alt=\"\"></p>\n<p>我们在代码有这样一个来自<code class=\"language-text\">ant</code>的<code class=\"language-text\">Pagination</code>组件对吧，可是在<code class=\"language-text\">react</code>中我们的断点实际只能打在这也就是函数的<code class=\"language-text\">return</code>的地方。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813845001799.jpg\" alt=\"\"></p>\n<p>此时我看到左边的调用栈，有<code class=\"language-text\">renderWithHooks</code>这样一个函数，这是<code class=\"language-text\">React</code>源码里调用函数组件的地方。</p>\n<p>这里有个很烦人的现象，我称它为迷失的断点，就是断到的位置发现是<code class=\"language-text\">14969</code>行，但他是个空行啊，正确的断点位置应该是红框的地方，因为那才是调用函数组件的地方。</p>\n<p>可是我们的断点还是要打在那个错误的绿行上，才能正常的使得断点工作。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813845759716.jpg\" alt=\"\"></p>\n<p>然后我们在这个空行上加一个条件断点，就是当组件的 name = Pagination 的时候\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813847992916.jpg\" alt=\"\"></p>\n<p>断住，ok 刷新一下重新跑，然后单步调试进入函数里，可以看到已经进入了<code class=\"language-text\">ant</code>的分页器，但这样不行，因为他是<code class=\"language-text\">babel</code>转前的并不是调试的源码。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813849270201.jpg\" alt=\"\"></p>\n<p>为什么会出现这种既是源码又不是源码的情况呢？</p>\n<p>代码经过了 <code class=\"language-text\">tsc</code> 的编译，然后又经过了 <code class=\"language-text\">babel</code> 的编译，最后再通过 <code class=\"language-text\">webpack</code> 打包成 <code class=\"language-text\">bundle.js</code>。</p>\n<p><code class=\"language-text\">tsc</code> 和 <code class=\"language-text\">babel</code> 的编译都会生成 <code class=\"language-text\">sourcemap</code>，而 <code class=\"language-text\">webpack </code>也会生成一个 <code class=\"language-text\">sourcemap</code>。</p>\n<p><code class=\"language-text\">webpack</code> 的 <code class=\"language-text\">sourcemap</code> 默认只会根据最后一个 <code class=\"language-text\">loader</code> 的 <code class=\"language-text\">sourcemap</code> 来生成。</p>\n<p>所以说上面我们用了 <code class=\"language-text\">sourcemap</code> 之后只能关联到 <code class=\"language-text\">babel</code> 处理之前的代码，像 <code class=\"language-text\">ts</code> 语法、<code class=\"language-text\">jsx</code> 代码这些都没有了。</p>\n<p>因为没有关联更上一级的 <code class=\"language-text\">ts-loader</code> 的 <code class=\"language-text\">sourcemap</code>，自然是没法直接映射回源码的。</p>\n<p>所以想映射回最初的 <code class=\"language-text\">tsx</code> 源码，只要关联了每一级 <code class=\"language-text\">loader</code> 的 <code class=\"language-text\">sourcemap</code> 就可以了。而这个是可以配置的，就是 <code class=\"language-text\">devtool</code>。</p>\n<p><code class=\"language-text\">devtool</code> 可以设置 <code class=\"language-text\">soruce-map</code>，就是生成 <code class=\"language-text\">sourcemap</code>，但是这个不会关联 <code class=\"language-text\">loader</code> 的 <code class=\"language-text\">sourcemap</code>。</p>\n<p>还可以设置 <code class=\"language-text\">cheap-module-source-map</code>，这个 <code class=\"language-text\">module</code> 就是关联 <code class=\"language-text\">loader</code> 的 <code class=\"language-text\">soruce-map</code> 的意思。（那个 <code class=\"language-text\">cheap</code> 是只保留行的 <code class=\"language-text\">sourcemap</code>，生成速度会更快）</p>\n<p>就<code class=\"language-text\">ant</code>的<code class=\"language-text\">node_modules</code>其实是有<code class=\"language-text\">map</code>文件的但生成的配置不对，此时我们应该找到<code class=\"language-text\">package.json</code>里对应的<code class=\"language-text\">ant</code>的版本先下下来。下图所示为<code class=\"language-text\">antd</code>源码的<code class=\"language-text\">packagejson</code>。</p>\n<p>然后讲一点<code class=\"language-text\">antd</code>的打包小知识，<code class=\"language-text\">antd</code>打包的所有逻辑是在<code class=\"language-text\">antd-tools</code>这个工具包里，有三种模式，<code class=\"language-text\">umd</code>、<code class=\"language-text\">es</code>、<code class=\"language-text\">cjs</code>，但我们如果要生成<code class=\"language-text\">sourcemap</code>最简单的方式只能是<code class=\"language-text\">umd</code>这种，<code class=\"language-text\">umd</code>是通过<code class=\"language-text\">webpack</code>去生成<code class=\"language-text\">sourcemap</code>，其他两种模式则是<code class=\"language-text\">glup</code>+<code class=\"language-text\">babel</code>+<code class=\"language-text\">tsc</code>去生成，但<code class=\"language-text\">babel</code>生成<code class=\"language-text\">sourcemap</code>需要插件（就其实就他们的开发者说的暂时不生成，要调自己用<code class=\"language-text\">umd</code>模式去自己生成调）。</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816514135772.jpg\" alt=\"\">\n好了，去找 ant-tools 把，他的打包内置逻辑在那里的，我想的是直接给他打 patch。</p>\n<p>可以看到我将固定的<code class=\"language-text\">webpack</code>的<code class=\"language-text\">sourcemap</code>配置改成了<code class=\"language-text\">cheap-module-source-map</code>,并且让他生成<code class=\"language-text\">sourcemap</code>,然后把跟目录下的 tsconfig 的<code class=\"language-text\">sourcemap</code>配置也改了。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813931367264.jpg\" alt=\"\"></p>\n<p>然后把生成的<code class=\"language-text\">dist</code>替换到项目里的<code class=\"language-text\">node_modules/antd/dist</code>来，可以复制也可以直接软连接。</p>\n<p>还有件事情，就是记得把缓存文件删了重新跑，<code class=\"language-text\">babel</code>的缓存文件也会导致不能正常的调试。</p>\n<p>ok，此时的调试就是直接调试的源码里的东西（这里可以看到是在<code class=\"language-text\">table</code>里，因为此时的<code class=\"language-text\">Pagination</code>是以<code class=\"language-text\">children</code>的形式在 Andt 源码的 table 中）。就可以愉快的玩耍。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813930908813.jpg\" alt=\"\"></p>\n<p>然后留个<a href=\"https://cdn.wsy.yn.cn/Sourcemap/antd.js.map\">map 文件 cdn 地址</a>，如果说以后大伙想调<code class=\"language-text\">antd 4.24.8</code>的源码（也就是 5 前的最后），直接把这个这个 map 文件替换项目中的，然后在业务代码中这样使用，相当于就是<code class=\"language-text\">umd</code>的使用方式<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16813936081490.jpg\" alt=\"\"></p>\n<p>、</p>\n<h1>4、调试 node.js</h1>\n<p>对于 <code class=\"language-text\">node</code> 来说，虽然也可以在浏览器调试但那种方式有点复杂且抽象就我们就直接放弃掉。我们直接看一下在 <code class=\"language-text\">node</code> 服务中如何去调试吧。</p>\n<h2>4.1、调试 Node 配置</h2>\n<p><code class=\"language-text\">node</code>的调试其实对于配置来说实在太多了（对于 node 很多的后端调试配置都可以拉上来了，就是因为我们项目里面现在没那种 node 服务嘛我就写点我们可能调试用得到的），我把一些常用的列出来。</p>\n<ul>\n<li><code class=\"language-text\">restart</code>: <code class=\"language-text\">attatch</code> 的时候可以指定尝试重连的次数和时间间隔</li>\n<li><code class=\"language-text\">processId</code>：除了可以通过网络端口，还可以通过进程 id 的方式 attach 到某个进程的调试服务</li>\n<li><code class=\"language-text\">program</code>：调试的 node 代码路径，可以通过 args 传参</li>\n<li><code class=\"language-text\">runtimeExecutable</code>：指定跑代码用的 runtime，默认是 node，也可以换成 ts-node、npm、pnpm 等，但要求这些命令在 PATH 环境变量里</li>\n<li><code class=\"language-text\">skipFiles</code>：折叠某些路径，不显示在调用栈里，比如 node 内部的一些代码</li>\n<li><code class=\"language-text\">stopOnEntry</code>：在首行断住</li>\n<li><code class=\"language-text\">autoAttachChildProcesses</code>：自动 attch 到子进程的调试服务</li>\n<li><code class=\"language-text\">console</code>：指定日志输出的位置，是内置的 console、terminal，还是外部的 terminal</li>\n<li><code class=\"language-text\">cwd</code>：跑 runtime 的目录</li>\n<li><code class=\"language-text\">env</code>：指定环境变量</li>\n<li><code class=\"language-text\">presentation</code>：对多个调试配置做分组和排序</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"启动程序\",\n      \"skipFiles\": [\"&lt;node_internals>/**\"],\n      \"program\": \"${workspaceFolder}/index.js\",\n      \"stopOnEntry\": true\n    }</code></pre></div>\n<h2>4.2、调试 Scripts 命令</h2>\n<p>首先我们可以看一下这种最新的<code class=\"language-text\">vscode</code>提供的直接的调试方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    {\n      \"name\": \"Launch via yarn\",\n      \"request\": \"launch\",\n      \"runtimeArgs\": [\"start\"],\n      \"runtimeExecutable\": \"yarn\",\n      \"skipFiles\": [\"&lt;node_internals>/**\"],\n      \"env\": {\n        \"NODE_ENV\": \"development\"\n      },\n      \"console\":\n      \"type\": \"node\"\n    },</code></pre></div>\n<p>正好前文提到了<code class=\"language-text\">antd</code>没做<code class=\"language-text\">esm</code>格式的<code class=\"language-text\">map</code>格式的处理，此时就让我们来看看为啥。</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816518217460.jpg\" alt=\"\"></p>\n<p>首先来点前置知识<code class=\"language-text\">antd</code>源码的<code class=\"language-text\">umd</code>走<code class=\"language-text\">pnpm dist</code>,<code class=\"language-text\">es、cjs</code>走<code class=\"language-text\">npm compile</code>，我自己加了一个只打包 Es 的 scripts 命令。</p>\n<p>配置如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    {\n      \"name\": \"Launch via PNPM\",\n      \"request\": \"launch\",\n      \"runtimeArgs\": [\"run-script\", \"compileEs\"],\n      \"runtimeExecutable\": \"npm\",\n      \"skipFiles\": [\"&lt;node_internals>/**\"],\n      \"type\": \"node\"\n    }</code></pre></div>\n<p>然后我们开始调试的过程。\n第一步 ：走到 Cli 注册命令的地方\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816521082907.jpg\" alt=\"\">\n第二步：走到注册<code class=\"language-text\">task</code>任务的地方\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816519744175.jpg\" alt=\"\">\n第三步：因为前两步有点过于简单了，我是直接看函数的名字，在最终的处理去打的断点反推回去的，就像是这样，我直接在<code class=\"language-text\">compile</code>这个函数里随便打了一个断点，左侧的调用栈就把之前整个流程很清晰的推理出来，并不需要你花时间去找，和分析那些变量是什么，你直接点开就可以看到。</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816523275034.jpg\" alt=\"\"></p>\n<p>第四步：直接到整个函数的尾部去打一个断点，去观察这个函数的所有变量的值是什么（其实在这里我就很讨厌<code class=\"language-text\">glup</code>流这种东西，因为没有什么观察的好办法在流的过程中），下图中，假如要生成<code class=\"language-text\">sourcemap</code>需要在 2 个地方改变配置，分别是<code class=\"language-text\">tsResult</code>这里是处理<code class=\"language-text\">typescript</code>的工作流、<code class=\"language-text\">tsFilesStream</code>这里是<code class=\"language-text\">babel</code>转译的工作流。对于<code class=\"language-text\">tsResult</code>是可以根据项目下的<code class=\"language-text\">tsconfig</code>去配置的，但最终的生成还是需要再<code class=\"language-text\">babel</code>转译的工作流中去处理也就是<code class=\"language-text\">babelify</code>，我们可以点进去看看为什么不方便生成<code class=\"language-text\">es</code>的<code class=\"language-text\">sourcemap</code>。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816526585506.jpg\" alt=\"\"></p>\n<p>第五步：断点进入<code class=\"language-text\">babelify</code>中，继续<code class=\"language-text\">getBabelCommonConfig</code>配置进去。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816538966799.jpg\" alt=\"\"></p>\n<p>第六步： 这里是<code class=\"language-text\">babel</code>的配置，但我们如果想生成<code class=\"language-text\">babel</code>的<code class=\"language-text\">sourcemap</code>配置，就需要在<code class=\"language-text\">preset</code>引入一个<code class=\"language-text\">sourcemap</code>的插件，但实际上如果不给<code class=\"language-text\">andt</code>提<code class=\"language-text\">pr</code>，我们即使是打<code class=\"language-text\">patch</code>也很难做到（实际也不是不行，但是会导致更多的问题或者自己去手肝一个 sourcemap 出来）。\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816539764296.jpg\" alt=\"\"></p>\n<h2>4.3、简单肝一个 sourcemap</h2>\n<p>前面我们说到，<code class=\"language-text\">sourcemap</code>是行和列的对应，那么<code class=\"language-text\">sourcemap</code>源码和目标代码的行列数是怎么来的那？</p>\n<p>其实我们在 <code class=\"language-text\">parse</code> 的时候就在 <code class=\"language-text\">AST</code> 节点中保存了 <code class=\"language-text\">loc</code> 属性，这就是源码中的行列号，在后面 <code class=\"language-text\">transform</code> 的过程中，并不会去修改它，所以转换完以后节点中仍然保留有源码中的行列号信息，在 <code class=\"language-text\">generate</code> 打印成目标代码的时候会计算出新的行列号，这样两者关联就可以生成 <code class=\"language-text\">sourcemap</code>。</p>\n<p>就像这样：\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816552176530.jpg\" alt=\"\"></p>\n<p>原理图：\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816546000683.jpg\" alt=\"\"></p>\n<p>然后要手肝不得不提一个包<a href=\"https://www.npmjs.com/package/source-map\">sourcemap</a>，我们可以用于生成和解析 <code class=\"language-text\">sourcemap</code>，需要手动操作 <code class=\"language-text\">sourcemap</code> 的时候可以用。我们通过它的 <code class=\"language-text\">api</code> 来感受下 <code class=\"language-text\">babel</code> 是怎么生成 <code class=\"language-text\">sourcemap</code> 的。</p>\n<p><code class=\"language-text\">source-map</code> 暴露了 <code class=\"language-text\">SourceMapConsumer</code>、<code class=\"language-text\">SourceMapGenerator</code>、<code class=\"language-text\">SourceNode</code> 3 个类，分别用于消费 <code class=\"language-text\">sourcemap</code>、生成 <code class=\"language-text\">sourcemap</code>、创建源码节点。</p>\n<h3>1、生成 sourcemap</h3>\n<p>生成 <code class=\"language-text\">sourcemap</code> 的流程是：</p>\n<p>1、创建一个 <code class=\"language-text\">SourceMapGenerator</code> 对象\n2、通过 <code class=\"language-text\">addMapping</code> 方法添加一个映射\n3、通过 <code class=\"language-text\">toString</code> 转为 <code class=\"language-text\">sourcemap</code> 字符串</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SourceMapGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">file</span><span class=\"token operator\">:</span> <span class=\"token string\">\"source-mapped.js\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">addMapping</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">generated</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">line</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">column</span><span class=\"token operator\">:</span> <span class=\"token number\">35</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">source</span><span class=\"token operator\">:</span> <span class=\"token string\">\"foo.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">original</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">line</span><span class=\"token operator\">:</span> <span class=\"token number\">33</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">column</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">\"christopher\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// '{\"version\":3,\"file\":\"source-mapped.js\",</span>\n<span class=\"token comment\">//   \"sources\":[\"foo.js\"],\"names\":[\"christopher\"],\"mappings\":\";;;;;;;;;mCAgCEA\"}、</span></code></pre></div>\n<h3>2、消费 sourcemap</h3>\n<p><code class=\"language-text\">SourceMapConsumer.with</code> 的回调里面可以拿到 <code class=\"language-text\">consumer</code> 的 <code class=\"language-text\">api</code>，调用 <code class=\"language-text\">originalPositionFor</code> 和 <code class=\"language-text\">generatedPositionFor</code> 可以分别用目标代码位置查源码位置和用源码位置查目标代码位置。还可以通过 <code class=\"language-text\">eachMapping</code> 遍历所有 <code class=\"language-text\">mapping</code>，对每个进行处理。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> rawSourceMap <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">version</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">file</span><span class=\"token operator\">:</span> <span class=\"token string\">\"min.js\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">names</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"baz\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"n\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">sources</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"one.js\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"two.js\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">sourceRoot</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://example.com/www/js/\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">mappings</span><span class=\"token operator\">:</span>\n    <span class=\"token string\">\"CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> whatever <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> SourceMapConsumer<span class=\"token punctuation\">.</span><span class=\"token function\">with</span><span class=\"token punctuation\">(</span>rawSourceMap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token parameter\">consumer</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 目标代码位置查询源码位置</span>\n  consumer<span class=\"token punctuation\">.</span><span class=\"token function\">originalPositionFor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">line</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">column</span><span class=\"token operator\">:</span> <span class=\"token number\">28</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// { source: 'http://example.com/www/js/two.js',</span>\n  <span class=\"token comment\">//   line: 2,</span>\n  <span class=\"token comment\">//   column: 10,</span>\n  <span class=\"token comment\">//   name: 'n' }</span>\n\n  <span class=\"token comment\">// 源码位置查询目标代码位置</span>\n  consumer<span class=\"token punctuation\">.</span><span class=\"token function\">generatedPositionFor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">source</span><span class=\"token operator\">:</span> <span class=\"token string\">\"http://example.com/www/js/two.js\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">line</span><span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">column</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// { line: 2, column: 28 }</span>\n\n  <span class=\"token comment\">// 遍历 mapping</span>\n  consumer<span class=\"token punctuation\">.</span><span class=\"token function\">eachMapping</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">m</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">computeWhatever</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">babel</code> 就是用这些 <code class=\"language-text\">api</code> 来生成 <code class=\"language-text\">sourcemap</code> 的，可惜没暴露出来用不了。</p>\n<h1>5、调试 React-native</h1>\n<p>首先你需要一个 <code class=\"language-text\">vscode</code> 插件， <code class=\"language-text\">React Native Tools</code>，然后基本套路是一样的。\n<a href=\"https://github.com/microsoft/vscode-react-native\">文档地址</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> {\n    \"name\": \"Debug iOS\",\n    \"request\": \"launch\",\n    \"type\": \"reactnative\",\n    \"target\": \"762B7175-79C6-4884-8245-BCB49670BE2D\",\n    \"cwd\": \"${workspaceFolder}\",\n    \"platform\": \"ios\"\n},</code></pre></div>\n<p>你需要\n<img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816555280930.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816555059239.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816555434315.jpg\" alt=\"\"></p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816555561330.jpg\" alt=\"\"></p>\n<p>此时在根据你的模拟器<code class=\"language-text\">id</code>链接就可以了直接调试<code class=\"language-text\">js</code>层面的东西了，而对于原生层面的内容是可以直接打断点的更加的方便和简单，比如<code class=\"language-text\">xcode</code>.</p>\n<p><img src=\"https://cdn.wsy.yn.cn/Sourcemap/16816557003659.jpg\" alt=\"\"></p>\n<h1>6、结束</h1>\n<p>其实，为什么要分享这个（虽然当时分享得很拉胯，完全不知道在想啥），因为这其实算是一个基础能力，类似于一种提效方法和辅助手段，因为人的脑子是有限的，如果你有一个保存上下文，随时可输入输出，暂停继续的手段，那么不管是在开发、bug 的疑难杂症、分析源码、学习代码的过程中都是一个潜移默化的提升。</p>\n<p>用 Debugger 可以看到调用栈，也就是代码的执行路径，每个栈帧的作用域，可以知道代码从开始运行到现在都经历了什么，而 console.log 只能知道某个变量的值。</p>\n<p>此外，报错的时候也可以通过异常断点来梳理代码执行路径来排查报错原因。</p>\n<p>但其实发现了一个问题没有，就是全貌/OR 分支，不管是我们分析代码还是打 debug,其实正常来说都是按照一条执行路径也就是分支，有时候可能我们再面临更复杂的情况需要更多的工具去分析就比如 performance、memory、charles 等。</p>","frontmatter":{"title":"前端调试","date":"2023-04-17","description":null,"author":"韦顺宇"}},"previous":{"fields":{"slug":"/backEnd/event-driver/事件驱动基本介绍/"},"frontmatter":{"title":"事件驱动使用指南"}},"next":{"fields":{"slug":"/backEnd/outerLinks/"},"frontmatter":{"title":""}}},"pageContext":{"id":"bb5a4749-6a7d-5341-8b0f-82daa0be83de","previousPostId":"b7b643c0-597d-5645-bbf6-b72719678871","nextPostId":"bb8b4066-cb6d-51d6-b565-c8c50fc5277c"}},"staticQueryHashes":["2841359383","3257411868"]}